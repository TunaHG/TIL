# Basic Theory

## 프로그래밍 언어의 발전

프로그래밍 언어의 발전 과정은 기계가 아닌 인간을 위한 과정

*   **기계어**
    컴퓨터가 이해하는건 0과 1밖에 없다. 다만, 대단히 빠르고 성실하며 정확하다.
    0과 1루 이루어진 기계가 이해할 수 있는 언어를 기계어라고 하며, 기계어 코드는 CPU에 따라 다르다.

*   **어셈블리어**
    기계어를 일상 용어로 표현한 것이 어셈블리어다.
    어셈블리(Assembly)는 니모닉(Mnemonic)과 기계어의 일대일 매칭 코드표를 의미한다.

    CPU마다 기계어가 다르기 때문에 마찬가지로 CPU마다 어셈블리어가 다르다.

    어셈블리어를 기계어로 번역해주는 소프트웨어를 어셈블러(Assembler)라고 한다.

*   **C언어**
    같은 일을 하는 프로그램의 소스 파일을 각 기계의 종류만큼 만들어야 했던 어셈블리어와는 달리 C언어가 등장하며 하나의 소스 파일을 각 기계에 맞는 컴파일러로 컴파일만 하면 각 기계에 맞는 기계어 목적 파일이 만들어지게 되었다. 그래서 싱글소스 즉, 하나의 소스파일만 만들면 된다.

    운영체제가 하드웨어의 특성을 추상화하고 컴파일러는 운영체제별로 만들어져 공급하게 되는데 그 운영체제들이 또 나름의 특성이 있었기에 하나의 소스로 각 기종별로 컴파일하기 전에 그 기종에 맞게 소스를 변경하는 작업이 필요했다.

*   **C++ 언어**
    C++은 C에 객체 지향 개념을 도입한 언어

*   **Java**
    진정한 객체 지향 언어
    C++은 순수 객체 지향 개념에 가장 충실한 언어이긴 하지만, 객체 없는 프로그래밍도 가능한 언어이다. 객체 지향 지원 언어.

    JVM과 같은 가상 머신을 활용하여 컴파일러를 기종별로 따로 구매해두지 않아도 되도록 하였다.
    해당 기종의 컴퓨터에 해당 기종용 JRE만 설치되어 있다면 실행하기 위한 목적파일인 오브젝트 파일만 가져가면 된다.

#### CBD, SOA

CBD, Component Based Development로 애플리케이션을 통짜로 개발하지 말고, 의미있는 단위로 구분하고 그 단위를 하나하나씩 부품으로 개발해 마치 레고 블록을 쌓아 올리듯 부품을 결합해 소프트웨어 제품을 완성하자는 방법론이자 기법이다.

SOA, Service Oriented Architecture로 개발이 아니라 실제 현실의 업무를 기준으로 개발하자는 사상이다.

각자 블록화 개발, 서비스 지향적인 개발일 뿐 제품과는 별개의 것이다.
개발자로서 갖춰야할 것 중 하나로는 그러한 말장난에 휘둘리지 말고 그 본질을 살펴서 취할것은 취하고 버릴 것은 버리는 선별해내는 능력이다.

## Java & Structured/Procedural Programming

### Java 프로그램의 개발과 구동

Java 개발환경을 이해하는 데에는 JVM의 존재와 역할을 아는 것이 필수적이다.
자바 개발 도구인 **JDK(Java Developement Kit)**를 이용해 개발된 프로그램은 **JRE(Java Runtime Environment)**에 의해 가상의 컴퓨터인 **JVM(Java Virtual Machine)**상에서 구동된다. 편의상 배포될 때에는 JDK가 JRE를 포함하고 JRE가 JVM을 포함하는 형태로 배포된다. JDK는 자바 소스 컴파일러인 javac.exe를 포함하고 있고, JRE는 자바 프로그램 실행기인 java.exe를 포함하고 있다. 
자바가 이런 구조를 택한 이유는 기존 언어로 작성된 프로그램은 각 플랫폼용으로 배포되는 설치파일을 따로 준비해야 했던 불편함을 없애기 위해서다. 이러한 자바의 특성을 **Write Once Run Anywhere**라고 한다. 

### 메모리를 사용하는 방식

기계어를 포함한 모든 프로그래밍 언어는 메모리를 코드 실행 영역과 데이터 저장 영역으로 구분해서 사용한다.
객체지향 프로그램에서는 데이터 저장 영역을 다시 Static, Stack, Heap의 세 개의 영역으로 분할해서 사용한다. 이 3개의 영역을 T 메모리라고 한다.
운영체제나 언어 자체를 개발하는 로우 레벨 개발자가 아닌 일반 개발자가 코드 실행 영역을 깊게 학습할 필요는 없다.

**main메소드가 실행될 때 메모리 변화**
JRE는 먼저 프로그램 안에 main() 메소드가 있는지 확인한다. 존재가 확인되면 JRE는 JVM을 부팅하여 프로그램 실행을 위해 준비한다. 
부팅된 JVM은 목적 파일을 받아 실행한다. JVM이 가장 먼저 하는 일은 전처리다. 모든 자바 프로그램이 반드시 포함하는 java.lang 패키지를 Static영역에 가져다 놓는다. 다음으로 개발자가 작성한 모든 클래스와 import한 패키지 역시 Static 영역에 가져다 놓는다.
main 메소드를 위해 스택 프레임이 Stack영역에 할당된다. 스택 프레임은 클래스 정의를 시작하는 중괄호를 제외하고 여는 중괄호를 만날 때마다 하나씩 할당된다.
이후 메소드의 인자 args를 저장할 변수 공간을 스택 프레임의 맨 밑에 확보한다. 즉, 메소드 인자들의 변수 공간을 할당하는 것이다.
이후 main 메소드 안의 첫 명령문을 실행한다.
닫는 중괄호를 만나면 스택 프레임이 소멸된다. 그리고 main() 메소드가 끝나면 JRE는 JVM을 종료하고 JRE 자체도 운영체제 상의 메모리에서 사라진다.

**변수와 메모리**
Main() 메소드 내에서 선언되는 변수는 main() 메소드 스택 프레임 안에 밑에서부터 차곡차곡 변수 공간을 마련한다.
선언된 변수에 값이 할당되면 메모리상에 마련된 공간에 값을 집어넣는다.
선언과 할당이 한 줄에서 이루어지는 것도 다를바 없이 선언된 이후 할당되는 두 개의 명령문으로 동작한다.

**블록구문과 메모리**
Main()메소드 내에서 선언된 if문 블록과 같은 경우 해당 if문의 스택 프레임이 main() 메소드의 스택 프레임 내에 중첩되어 생성된다.
역시 if 블록을 종료하는 닫는 중괄호를 만나면 if 블록 스택 프레임은 Stack 영역에서 사라진다.

**지역변수와 메모리**
변수는 Static, Stack, Heap 세 군데 영역 모두에 있을 수 있다. 각각에 있는 변수는 각기 다른 목적을 가진다. 이름도 클래스 멤버 변수, 지역 변수, 객체 멤버 변수로 다르다.
지역 변수는 Stack 영역의 스택 프레임에서 일생을 보낸다. 따라서 스택 프레임이 사라지면 함께 사라진다. 외부 스택 프레임에서 내부 스택 프레임의 변수에 접근하는 것은 불가능하지만 그 역은 가능하다. 
클래스 멤버 변수는 Static 영역에서 일생을 보내며 한번 자리 잡으면 JVM이 종료될 때까지 고정된 상태로 그 자리를 지킨다.
객체 멤버 변수는 Heap 영역에서 일생을 보낸다. 객체와 함께 GC에 의해 일생을 마친다.

**메소드 호출과 메모리**
main메소드에서 다른 메소드를 호출하면 해당 메소드의 스택 프레임이 생성된다.
이러한 메소드 스택 프레임에는 반환값을 저장할 변수가 가장 아래, 그 위에 인자를 저장할 변수 공간, 그리고 가장 위에 메소드의 지역 변수가 자리잡는다. 반환값은 메소드가 종료되면서 반환해줄 값을 가지고 있는 가상의 변수다.
main() 메소드가 가진 변수와 호출된 메소드가 가진 변수 중 이름이 같은 변수가 있을 수 있다. 하지만 이름만 같지 실제로는 별도의 변수공간이다. 이것을 Call By Value라고 한다. 호출된 메소드 안에서 동일한 이름의 변수에 무슨 짓을 해도 main() 메소드 안의 동일한 이름의 변수에는 영향이 없다.
호출된 메소드에서 main() 메소드 내의 지역 변수를 참조할 수 없는 이유는 다음과 같다.

1.  메소드는 서로의 고유 공간이기 때문이다.
2.  포인터 문제 때문이다.
    호출된 메소드에서 main() 메소드의 지역 변수에 접근하려고 하면 해당 지역 변수의 위치를 명확히 알아야 하는데 그러기 위해서는 변수의 메모리 위치 즉, 포인터라고 읽고 메모리 주소 값이라 이해하는 그 값을 알아야 한다. 자바에서는 포인터가 없다.
3.  실전에서 사용되는 메소드는 다양한 곳에서 호출되기 때문이다.
    A 메소드를 호출하는 B, C, D 메소드가 존재하는 경우 각 메소드에서 호출한 경우에 따라 각 메소드의 지역 변수에 접근하려면 결국 그 지역 변수의 메모리 주소 값인 포인터를 이용해 접근해야만 한다.
    또 메소드를 호출하며 만들어지는 스택 구조는 항시 변화한다. A, B, C 순서대로 메소드 스택 프레임들이 구성될 수도 있고, A, C 또는 F, D, C처럼 호출되어 구성될 수도 있다는 것이다. 이 때 C 메소드 내의 변수가 하단 메소드 스택 프레임 중의 한 변수를 참조한다면 어느 메소드 스택 프레임의 변수를 참조해야 하는가 라는 문제가 발생한다. 결국 한 곳에 있는 메소드 내부의 지역 변수를 참조하려면 포인터가 필요해진다.

메소드 사이에 값을 전달하거나 반환하는 방법은 메소드의 인자와 반환값으로만 가능하다는 사실을 기억해둔다. 물론 전역 변수도 있지만 가급적 전역 변수는 사용하지 않는 것이 좋다.

**전역 변수와 메모리**
두 메소드 사이에 값을 전달하는 방법으로 전역 변수를 사용하는 방법이 있다.
`static`키워드가 붙은 변수는 메모리 Static 영역에 할당된다. 해당 클래스가 Static 영역에 배치될 때 그 안에 static 키워드 변수가 클래스의 멤버로 공간을 만들어 저장된다. 이는 메소드들 사이에서 공유해서 사용할 수 있는 전역 변수가 된다.
전역 변수는 코드 어느 곳에서나 접근할 수 있다고 해서 전역 변수라고 하며, 여러 메소드들이 공유해서 사용한다고 해서 공유 변수라고도 한다.
전역 변수는 왜 사용하지 말아야 할까?
프로젝트 규모에 따라 코드가 커지면서 여러 메소드에서 전역 변수의 값을 변경하기 시작하면 메모리로 추적하지 않는 이상 전역 변수에 저장되어 있는 값을 파악하기 쉽지 않기 때문이다. 다만 읽기 전용으로 값을 공유해서 전역 상수로 사용하는 것은 적극 추천한다. Math클래스에 이미 정의된 PI 전역 상수처럼 사용하는 것은 좋다.

### 절차적/구조적 프로그래밍

절차적 프로그래밍을 간단히 표현하면 goto를 사용하지 않는 것이다.
Java에서는 goto를 사용하지말라고 예약어로 선점해놓고, 공식문서에서 사용하지 말라고 명시해두었다. 공식문서에 사용하지 말라고 명시된 const는 final이 대신하고 있기에 not used로 명시되어 있다.

왜 사용하지 말라고 할까?
goto를 사용하게되면 프로그램의 실행 순서가 인간이 이해하기에 너무 복잡해질 가능성이 있기 때문이다. goto를 사용하게 되면 프로그램의 실행 순서를 이리저리 이동할 수 있게 되는데, 이러한 이동이 잦아지면 소스를 이리저리 따라가며 프로그램을 이해해야 하기 때문에 좋지 않다. 이러한 이동은 프로그램을 논리적으로 잘 구성하면 모두 피할 수 있는 것들이다. 그래서 자바에서 사용을 금지하는 것이다.

구조적 프로그래밍은 함수를 사용하는 것이다.
함수를 사용하면 중복 코드를 한 곳에 모아서 관리할 수 있고, 논리를 함수 단위로 분리해서 이해하기 쉬운 코드를 작성할 수 있다.

Java언어에서는 이러한 절차/구조적 프로그래밍의 흔적을 메소드에서 확인할 수 있다.
자바의 예약어 중 절반 이상이 절차적/구조적 프로그래밍 언어에서 유래됐다.

### 멀티 스레드 / 멀티 프로세스의 이해

멀티 스레드의 T 메모리 모델은 Stack 영역을 스레드 개수만큼 분할해서 사용하는 것이다.
멀티 프로세스는 다수의 데이터 저장 영역 즉, 다수의 T 메모리를 갖는 구조이다.

멀티 프로세스는 하나의 프로세스가 다른 프로세스의 T 메모리 영역을 절대 침범할 수 없는 메모리 안전한 구조이지만 메모리 사용량은 그만큼 크다.
멀티 스레드는 하나의 T 메모리 안에서 Stack 영역만 분할한 것이기 때문에 하나의 스레드에서 다른 스레드의 스택 영역에는 접근할 수 없지만 스태틱 영역과 힙 영역은 공유해서 사용하는 구조다. 그래서 멀티 프로세스 대비 메모리를 적게 사용한다. 

멀티 스레드에서 전역 변수를 사용하게 되면 스레드 1에서 사용하는 변수를 스레드 2에서 변경할 수 있기 때문에 스레드 안정성이 깨진다. 이를 보완하는 방법으로 락(lock)을 거는 방법이 있지만 락을 거는 순간 스레드의 장점은 버린 것과 같다.