# Java & Object Oriented

>   자바와 객체 지향!

**객체 지향은 현실 세계를 반영한다.**
기존의 구조적 프로그래밍 언어에서 가장 중요한 것은 함수였다. 코드를 논리적인 단위로 구분하고 분할해서 정복하자는 의미였다.
이후에 발전한 것이 객체 지향이다. 0과 1로 대변되는 컴퓨터에 맞춰 사고하던 방식을 버리고 현실세계를 인지하는 방식으로 프로그램을 만들자는 것이다. 그래서 <u>객체 지향은 직관적이다.</u>

사물을 하나하나 이해하기 보다는 사물을 분류해서 이해하며 각 사물은 고유하고, 속성을 가지며, 행위를 한다.
여기서 사람이라는 사물은 나이, 몸무게, 키라는 속성을 가지며 먹고, 자는 행위를 한다. **속성을 필드, 행위를 메소드라 부른다.** 

## 객체 지향의 4대 특성

### 클래스 vs 객체

기존에 공부했던 붕어빵틀과 붕어빵은 클래스와 객체 관계가 아니다. 붕어빵틀은 붕어빵을 만드는 팩토리다.

클래스와 객체를 구분하는 간단한 방법은 나이를 물어보는 것이다. 사람과 김연아를 비교했을 때 사람의 나이는 특정 지을 수 없으므로 클래스이고 김연아의 나이는 찾아보면 특정 지을 수 있으므로 객체다.
**클래스는 분류에 대한 개념이지 실체가 아니고, 객체는 실체다.** 

객체 지향에서 말하는 객체는 세상에 존재하는 유일무이한 사물을 의미한다. 또 이러한 객체는 생물이건 무생물이건 속성과 기능을 가지고 있다.
이와 대비되는 클래스의 정의는 분류, 집합. 같은 속성과 기능을 가진 객체를 총칭하는 개념이다.

### 캡슐화

>   Encapsulation, 정보 은닉

자바에서 정보 은닉이라고 하면 **접근 제어자인 private, [default], protected, public**이 생각난다.
접근 제어자들을 고려한 멤버 접근에 대해 고민해봐야 한다. protected의 경우 서브 클래스에만 접근 가능한 걸로 착각하는 경우가 많은데, 같은 패키지라면 접근 가능하다는 사실도 기억해야 한다. aaa.jar 파일과 bbb.jar 파일내에 동일한 이름의 패키지가 존재한다면 aaa.jar의 해당 패키지 내 클래스나 객체에서 bbb.jar파일의 해당 패키지 내 클래스나 객체가 가진 public 멤버 뿐만 아니라 default, protected 멤버에 자유롭게 접근할 수 있다는 점도 고려해야 한다. 

**상속을 받지 않았다면 객체 멤버는 객체를 생성한 후 객체 참조 변수를 이용해 접근해야 한다.** 

**정적 멤버는 클래스명.정적멤버 형식으로 접근하는 것을 권장한다.** 일관된 형식으로 접근하기 위해서인데 객체참조변수명.정적멤버 형태로도 접근할 수 있으나 클래스명으로 활용하는 것을 권장한다. 메모리의 물리적 접근으로 생각해봐도 객체참조변수명을 활용하면 메소드 스택프레임을 거쳐 힙 영역에 존재하는 객체에서 값을 가져오지만, 클래스 명을 활용하면 스태틱 영역에서 값을 바로 가져오기 때문에 더욱 효율적이다. 

### 상속

>   Inheritance, 재사용

**객체 지향에서 상속이란, 상속이 아닌 재사용과 확장으로 이해해야 한다.** 상위 클래스의 특성을 하위 클래스에서 상속하고 거기에 더해 필요한 특성을 추가, 확장해서 사용할 수 있다는 의미다. 부모 - 자식과 같은 계층도나 조직도가 아닌 동물 - 포유류같은 분류도를 의미한다.

상속관계에서는 하위클래스는 상위클래스다. 라는 조건을 만족해야한다. 아들은 아버지다. 라는 것은 모순이고, 포유류는 동물이다.는 조건을 만족한다.
이는 객체 지향 설계 5원칙 중 LSP를 나타내는 말이기도 하다.

또한 자바 언어에서 inheritance(상속)이라는 키워드는 존재하지 않는다. 대신 **extends**(확장)이 존재한다.

**상위 클래스에서 구현한 메소드를 하위 클래스에서 사용할 수 있다.** 상속한다는 것이 이렇게 상위 클래스의 특성을 상속한다는 의미지 부모-자식관계는 아니다. 하위 클래스에서 해당 메소드를 구현하지 않아도 된다는 점, 재사용할 수 있다는 점이 상속의 강력함 중 하나이다.
또 다른 강력함으로는 **객체 선언시 객체의 타입은 상위 클래스로 선언할 수 있다는 점**이다. 또한 클래스 상속구조에서 최상위 클래스는 Object이므로 모든 클래스가 Object의 특성을 물려받아 toString()를 사용할 수 있다는 점도 강력한 점이다.

상속은 **is a 관계**다 라는 말이 많은데, 정확히 얘기하면 **is a kind of 관계**라는 표현이 바람직하다. a를 단수 명사 앞에 쓰여 그 부류를 통칭함으로 해석하면 옳은 해석이 되지만, 하나의 명사라는 표현으로 해석하면 옳지 않은 관계로 표현될 수 있기 때문이다.

**자바에서는 다중 상속을 지원하지 않는다.** 예를 들어, 인어가 사람과 물고기를 상속한다고 가정했을 때 사람도 수영할 수 있고 물고기도 수영할 수 있는데 그를 상속받은 인어는 어떻게 수영할 것인가? 라는 문제가 발생한다. 이 문제를 다중 상속의 다이아몬드 문제라고 한다. 이 문제 때문에 자바에서는 다중 상속을 포기하고 **인터페이스**를 도입해 득은 취하고 실은 버렸다.

**인터페이스**
인터페이스는 be able to 라는 표현 형태로 만드는 것이 좋다. 자바 API에서도 이러한 형식의 인터페이스를 확인할 수 있다. Serializable, Cloneable, Comparable 등의 인터페이스가 그 예시다.
인터페이스의 예시를 들어보자면 박쥐는 날 수 있다, 참새는 날 수 있다와 같이 날 수 있다는 인터페이스로 구현할 수 있다.
<u>상위클래스는 물려줄 특성이 풍성할수록 좋고, 인터페이스는 구현을 강제할 메소드의 개수가 적을수록 좋다. 이는 객체 지향 설계 5원칙 중 LSP와 ISP에 따른 이유이다.</u>

**상속과 메모리**
<u>하위 클래스의 객체가 할당될 때, 힙 영역에는 해당 인스턴스만 생성되는 것이 아니라 상위 클래스의 인스턴스도 함께 생성된다.</u> 그래서 선언된 객체의 타입이 상위 클래스가 되는 것이 가능한데, 이 경우 하위 클래스와 상위 클래스의 인스턴스가 같이 생성되나 변수의 주소가 가르키는 주소가 상위 클래스의 인스턴스의 주소가 된다. 그러므로 하위 클래스의 메소드와 속성은 사용하지 못한다. 같은 원리로 선언된 객체의 타입이 상위 클래스일 경우, 하위 클래스의 인스턴스를 할당할 수 없다. 상위 클래스의 인스턴스에 하위 클래스의 인스턴스가 같이 생성되지 않기 때문이다.

### 추상화

>   Abstraction, 모델링

추상의 사전적 의미는 여러가지 사물이나 개념에서 공통되는 특성이나 속성 따위를 추출하여 파악하는 작용이다.
**추상화란 구체적인 것을 분해해서 관찰자가 관심 있는 특성만 가지고 재조합하는 것이라고 정리할 수 있다.**

사람 클래스를 예로 들어서 생각해보면, 사람들이 가진 공통된 특성을 찾아 본다.
시력, 몸무게, 혈액형, 키, 나이, 직업, 취미 등등 명사로 표현되는 특성을 속성이라 한다. 속성은 값을 가질 수 있다.
먹다, 자다, 일하다, 운전하다, 울다 등등 동사로 표현되는 특성을 기능/행위라 한다. 이는 수행 절차 또는 로직을 가지게 된다. 이를 메소드라 한다.

하지만 사람 클래스가 사람 객체들의 모든 특성을 가져야 할까?
애플리케이션 경계에 따라 달라져야 한다. <u>애플리케이션 경계</u>란, 컨텍스트라고도 하며 애플리케이션이 어디에 사용될 것인지에 대한 구분이다.
사람 클래스는 애플리케이션 경계에 따라 필요한 속성과 메소드만 가지고 있으면 된다.
이를 이용해 추상화의 정의를 생각해보면 다음과 같다.
**구체적인 것을 분해해서 관심 영역(애플리케이션 경계)에 있는 특성만 가지고 재조합하는 것.**
이는 곧 <u>모델링</u>을 의미한다. 

그래서 추상화는 모델링이라고 하는 것이다.
모델은 실제 사물을 정확히 복제하는 게 아니라 목적에 맞게 관심 있는 특성만을 추출해서 표현하는 것이다. 추상화를 통해 실제 사물을 단순하게 묘사한다고 할 수 있다. 

**추상화와 메모리**
java.lang 패키지와 모든 클래스들이 T 메모리의 Static 영역에 배치된다. 하지만 이 때 추상화를 위해 생성해둔 클래스에서 변수 저장공간은 존재하지 않는다. 객체가 생성돼야만 속성의 값을 저장하기 위한 메모리 공간이 Static 영역이 아닌 힙 영역에 할당되기 때문이다.
Main() 메소드는 클래스의 멤버 메소드를 의미하고, 객체를 위한 클래스의 메소드는 객체의 멤버 메소드라고 한다. 두 멤버를 구분하는 자바의 키워드는 static이다.

쥐의 꼬리와 같이 값이 1개일 경우, 이것을 객체의 속성으로 지정하면 객체의 수만큼 메모리를 잡아먹는다. 같은 클래스의 모든 객체가 같은 값을 가지고 있다면 그 값을 클래스에 저장할 수 있다. static 키워드를 사용한다. 클래스를 선언할 때 꼬리 속성에 static 키워드를 활용하면 T 메모리의 Static 영역에 단 하나의 저장공간을 가진다. 객체를 이용해 변수에 접근할 수 있다. 속성 뿐만 아니라 메소드도 static 키워드를 붙였냐 안붙였냐에 따라 클래스 멤버 메소드, 객체 멤버 메소드로 분류한다. Main() 메소드처럼 static이 붙은 메소드가 클래스 멤버 메소드이다.
클래스는 JVM 구동 시 T 메모리의 스태틱 영역에 바로 배치되기 때문에 객체의 존재 여부에 관계 없이 사용할 수 있다. T 메모리가 초기화된 순간 객체는 하나도 존재하지 않기 때문에 객체 멤버 메소드를 바로 실행할 수 없다. 그래서 main() 메소드는 클래스 멤버 메소드여야 한다. 

정적 속성(Static)인 경우 T 메모리의 스태틱 영역에 클래스가 배치될 때 클래스 내부에 메모리 공간이 확보되는 것을 보여준다. 그에 반해 객체 속성은 속성명만 있지 실제 메모리 공간은 확보하지 않는다. 객체 속성은 힙 영역에 객체가 생성되면 그때 각 객체 안에 멤버 속성을 위한 메모리 공간이 할당된다. 

스택 영역에 생성되는 지역 변수는 개발자가 초기화해줘야 하지만, 클래스 속성과 객체 속성은 별도로 초기화를 해주지 않아도 자동으로 초기화된다. 이는 멤버 변수는 공유 변수의 성격을 가지고 있기 때문이다. 객체 변수는 하나의 객체 안에서 다수의 객체 메소드가 공유하는 변수이고, 클래스 변수는 전역 변수로서 프로그램 어디서든 접근 가능한 변수다. 객체 멤버인 경우 생성자를 통해, 정적 멤버는 정적 실행 영역을 통해 초기화 하는 경우가 있지만 공유 변수는 누가 초기화해야 한다고 규정할 수 없기에 별도로 초기화를 하지 않아도 기본값으로 초기화되는 것이다. 

### 다형성

>   Polymorphism, 사용 편의

객체 지향에서 다형성이라고 하면 **오버라이딩(Overriding)**과 **오버로딩(Overloading)**이라고 할 수 있다.
물론 상위 클래스와 하위 클래스 사이에서, 인터페이스와 그것의 구현 클래스 사이에서도 이야기 할 수 있지만 기본은 오버라이딩과 오버로딩이다.
*오버로딩이 다형성인지 아닌지에 대해서는 이견이 있다.*

**오버라이딩**은 <u>상위 클래스 혹은 인터페이스에서 선언한 메소드를 하위 클래스 혹은 구현 클래스에서 같은 메소드 이름과 같은 매개변수 리스트를 가지고 다시 선언하여 기능을 재정의하는 것</u>을 의미한다.
**오버로딩**은 <u>같은 메소드 이름을 가졌으나 다른 매개변수 리스트를 가지고 선언하여 기능을 중복적으로 정의하는 것</u>을 의미한다.

**다형성과 메모리**
상위 클래스의 메소드가 하위 클래스에서 오버라이딩, 오버로딩 되었다고 가정하였을 때, 하위 클래스의 타입으로 선언하고 할당된 객체는 오버라이딩, 오버로딩된 메소드를 실행한다. 주의할 점은 상위 클래스의 타입으로 선언하고 하위 클래스의 인스턴스가 할당된 객체의 경우에도 상위 클래스의 메소드를 실행하는 것이 아닌 오버라이딩된 하위 클래스의 메소드를 실행한다는 점이다.
**상위 클래스 타입의 객체 참조 변수를 사용하더라도 하위 클래스에서 오버라이딩한 메소드가 호출된다는 사실을 기억해야 한다.**

**다형성이 지원되지 않는 언어**
간단하게 두 숫자를 반환하는 함수가 있다고 가정하였을 때, 다형성이 지원되지 않는 언어에서는 add(int, int)와 addIntDouble(int, double), addDoubleInt(double, int) 처럼 필요한 경우의 수를 모두 생각하여 각각의 메소드 명을 변경하며 구현해야 한다. 하지만 다형성이 지원되면 오버로딩은 함수명 하나를 가지고 인자 목록만 달리하면 되니 편리하다. 특히 자바 5에서 추가된 제네릭을 이용하면 하나의 함수만 구현해도 다수의 함수를 구현한 효과를 낼 수 있다.
오버라이딩의 경우에도 하위 클래스가 재정의한 메소드를 알아서 호출해 줌으로써 형변환이나 instanceof 연산자를 써서 하위 클래스가 무엇인지 신경쓰지 않아도 된다.

### 참조 변수의 복사

기본 자료형 변수를 복사하는 경우 Call By Value에 의해 그 값이 복사되며 두 개의 변수는 서로에게 영향을 주지 않는다.
기본 자료형이 아닌 객체를 저장하고 있는 객체 참조 변수를 복사하는 경우 Call By Reference 혹은 Call By Address라고 불리며 주소값을 복사한다.

본질적으로 Call By Value와 Call By Reference의 차이는 없다. 다만, 기본 자료형 변수는 저장하고 있는 값을 그 값 자체로 해석하는 반면, 객체 참조 변수는 저장하고 있는 값을 주소로 해석한다는 차이가 있을 뿐이다. 변수를 복사하든 참조 변수를 복사하든 결국은 변수가 가진 값이 그대로 복사된다. 다만 그 값을 값 자체로 해석하느냐 아니면 주소값으로 해석하느냐의 차이일 뿐이다.

# Object Oriented extended by Java

자바가 객체 지향을 확장하기 위해 사용하는 키워드와 개념을 알아본다.

## Abstract

**추상 메소드와 추상 클래스**
추상 메소드는 선언부는 있는데 구현부가 없는 메소드를 의미한다. 또한 추상 메소드를 하나라도 가지고 있는 클래스는 반드시 추상 클래스로 선언해야 한다. 추상 메소드 없이 추상 클래스를 선언할 수는 있다. 
상위 클래스 타입으로 선언되고, 하위 클래스의 인스턴스를 할당받는 객체에서 메소드를 호출할 때 해당 메소드는 하위 클래스의 메소드를 실행한다. 이 때 상위 클래스에 해당 메소드가 선언되어 있어야 한다. 하지만 상위 클래스에서 해당 메소드가 하는 역할이 없을 경우, 만약 상위 클래스의 인스턴스를 할당받는 객체에서 해당 메소드를 호출하면 동작이 이상해진다. 이런 경우 추상 메소드를 사용한다. 메소드 선언은 있으나 몸체는 없는 형태로 구현하는 것이다.

이렇게 추상 클래스로 선언된 상위 클래스의 경우 상위 클래스의 인스턴스를 생성할 수 없다. 뿐만 아니라 추상 클래스를 상속받은 하위 클래스에서 추상 메소드를 오버라이딩 하지 않으면 컴파일 시점에 에러가 발생한다. 

**결론적으로, 추상클래스는 인스턴스(객체)를 만들 수 없고 추상 메소드는 하위 클래스에게 추상 메소드의 오버라이딩을 강제하며 추상 메소드를 포함하는 클래스는 반드시 추상 클래스여야 한다.**

## Constructor

클래스의 인스턴스, 객체를 만들 때마다 new 키워드를 사용한다. 이 때 클래스 명에 붙는 소괄호는 클래스명()의 메소드이다. 반환값이 없고 클래스명과 같은이름을 가진 메소드를 객체를 생성하는 메소드라고 하여 객체 생성자 메소드라고 한다. 줄여서 생성자라 부른다. 자바에서는 기본 생성자를 자동으로 만들어준다. 필요하다면 인자를 가지는 생성자를 더 만들 수 있다. 다만, **개발자가 아무런 생성자도 만들지 않으면 자바가 인자가 없는 기본 생성자를 만들어주지만 인자가 있는 생성자를 하나라도 만든다면 자바가 기본 생성자를 만들어주지 않는다.**

또한 생성자는 개발자가 필요한 만큼 오버로딩해서 만들 수 있다.

## 클래스 생성 시의 실행 블록, Static 블록

클래스는 생성자가 존재하지 않는다. 그러나 클래스가 스태틱 영역에 배치될 때 실행되는 코드 블록이 있다. 바로 Static 블록이다. 

```java
public class test {
  static {
    System.out.println("Test print");
  }
}
```

위와 같이 static 블록을 선언해주면 되며, 해당 클래스 생성시에 static 블록이 실행될 것이다. 

static 블록에 사용할 수 있는 속성과 메소드는 당연히 static 멤버 뿐이다. T 메모리를 생각해보면 객체 멤버에 접근할 방법이 없다는 것을 알 수 있다. 객체 멤버는 클래스가 Static 영역에 자리 잡은 후에 객체 생성자를 통해 힙에 생성된다. 클래스의 static 블록이 실행되고 있을 때는 해당 클래스의 객체는 하나도 존재하지 않기 때문에 static 블록에서는 객체 멤버에 접근할 수 없는 것이다.

실제로 클래스가 메모리에 로딩되는 때는 처음으로 사용될 때이다. 그래서 new 키워드를 사용하여 클래스를 로딩할 때 해당 영역이 생성되지 해당 클래스를 호출하지도 않는다면 test print는 출력되지 않는다. 클래스의 정적 속성에 접근할 때도 마찬가지다. 클래스가 로딩되지 않고 있다가 정적 속성에 접근할 때 클래스를 로딩한다.
정리하면, 클래스 정보는 해당 클래스가 코드에서 맨 처음 사용될 때 T 메모리의 스태틱 영역에 로딩되며, 이 때 단 한번 해당 클래스의 static 블록이 실행된다. 클래스가 맨 처음 사용될 때는 클래스의 정적 속성을 사용하거나 정적 메소드를 사용하거나, 인스턴스를 최초로 만들 때를 의미한다.

스태틱 영역도 메모리이기 때문에 최대한 늦게 사용을 시작하고 최대한 빨리 반환하는 것이 정석이다. 자바는 스태틱 영역에 한번 올라가면 프로그램이 종료되기 전까지 해당 메모리를 반환할 수 없지만 그럼에도 최대한 늦게 로딩함으로써 메모리 사용을 최대한 늦추기 위해서다. 실무에서 static 블록을 사용할 일은 거의 없지만 그래도 특성을 기억해두면 언젠가 한번은 써먹을 일이 있을 것이다.

참고로 아무런 표시없이 {} 블록을 사용하게 되면 인스턴스 블록을 의미하며 인스턴스가 생성될 때마다 블록이 실행된다. 객체 생성자가 실행되기 전에 먼저 실행된다. 객체는 주로 생성자를 통해 초기화하기 때문에 거의 사용할 일은 없지만 알아둔다.

## final

final은 마지막, 최종을 의미하며 해당 키워드가 나타날 수 있는 곳은 클래스, 변수, 메소드 세 군데이다.

**final 클래스**
클래스에 final 키워드가 붙게되면 상속을 허락하지 않겠다는 의미다. 따라서 하위 클래스를 만들 수 없다.

**final 변수**
변수에 final 키워드가 붙게되면 변경 불가능한 상수가 된다.
정적 상수는 선언 시에, 또는 정적 생성자에 해당하는 static 블록 내부에서 초기화가 가능하다. 객체 상수 역시 선언 시에, 또는 객체 생성자 또는 인스턴스 블록에서 초기화할 수 있다. 지역 상수 역시 선언 시에, 또는 최초 한 번만 초기화가 가능하다.

다른 언어에서는 읽기 전용인 상수에 대해 final 대신 const 키워드를 사용하기도 하는데 자바에서는 이런 혼동을 피하기 위해 const를 키워드로 등록해두고 쓰지 못하게 하고 있다.

**final 메소드**
메소드에 final 키워드가 붙으면 오버라이딩을 할 수 없다.

## instanceof

인스턴스는 클래스를 통해 만들어진 객체다. instanceof 연산자는 만들어진 객체가 특정 클래스의 인스턴스인지 물어보는 연산자다.
instanceof 연산자는 결과로 true 혹은 false를 반환한다.

객체 참조 변수의 타입이 아닌 실제 객체의 타입에 의해 처리한다.

instanceof 연산자가 강력하지만 LSP 원칙을 어기는 코드에서 주로 나타나는 연산자기 때문에 해당 연산자가 보인다면 리팩토링의 대상이 아닌지 점검해봐야 한다.

instanceof 연산자는 클래스들의 상속 관계뿐만 아니라 인터페이스의 구현 관계에서도 동일하게 적용된다.

## package

package 키워드는 네임스페이스를 만들어주는 역할을 한다.

동일한 클래스에 대해 이름 충돌을 방지하기 위해 package.클래스명을 활용한다.

## interface, implements

interface는 public 추상메소드와 public 정적 상수만 가질 수 있다.

직접 키워드로 명시할 필요없이 따로 메소드에 public, abstract, 속성에 public, static, final을 붙이지 않아도 자바에서 자동으로 붙여준다.

자바에서 람다는 인터페이스를 기초로 하고 있다. 그래서 람다가 나온 자바8부터는 인터페이스에도 큰 변화가 생겼다.
자바 8부터는 디폴트 메소드라고 하는 객체 구상 메소드와 정적 추상 메소드를 지원할 수 있게 언어 스펙이 바뀌었다.

## this

this는 객체가 자기 자신을 지칭할 때 쓰는 키워드다.

지역 변수와 속성(객체 변수, 정적 변수)의 이름이 같은 경우 지역 변수가 우선한다.
객체 변수와 이름이 같은 지역 변수가 있는 경우 객체 변수를 사용하려면 this를 접두사로 사용한다.
정적 변수와 이름이 같은 지역 변수가 있는 경우 정적 변수를 사용하려면 클래스명을 접두사로 사용한다.

## super

this 키워드가 객체 멤버 메소드 내부에서 객체 자신을 지칭하는 키워드라면 super 키워드는 상위 클래스의 인스턴스를 지칭하는 키워드다.

하지만 super.super 형태로 상위의 상위 클래스의 인스턴스에 접근하는 것은 불가능하다.

# Object-oriented design principles

>   SOLID

SOLID는 5가지 원칙의 앞 머리 알파뱃을 따서 부르는 이름이다.

*   **SRP(Single Responsibility Principle), 단일 책임 원칙**
*   **OCP(Open Closed Principle), 개방 폐쇄 원칙**
*   **LSP(Liskov Substitution Principle), 리스코프 치환 원칙**
*   **ISP(Interface Segregation Principle), 인터페이스 분리 원칙**
*   **DIP(Dependency Inversion Principle), 의존 역전 원칙**

이 원칙들은 응집도를 높이고 결합도는 낮추는 고전 원칙을 객체 지향 관점에서 재정립한 것이다.

**결합도와 응집도**
<u>좋은 설계를 위해서는 결합도(coupling)는 낮추고 응집도(cohesion)는 높이는 것이 바람직하다.</u>
결합도는 모듈(클래스)간의 상호 의존 정도로서 결합도가 낮으면 모듈 간의 상호 의존성이 줄어들어 객체의 재사용이나 수정, 유지보수가 용이하다.
응집도는 하나의 모듈 내부에 존재하는 구성 요소들의 기능적 관련성으로, 응집도가 높은 모듈은 하나의 책임에 집중하고 독립성이 높아져 재사용이나 기능의 수정, 유지보수가 용이하다.

**결합도 수준**은 데이터 결합도, 스탬프 결합도, 컨트롤 결합도, 외부 결합도, 공유 결합도, 내용 결합도가 존재한다.
**응집도 수준**은 기능 응집도, 순차 응집도, 통신 응집도, 절차 응집도, 시간 응집도, 논리 응집도, 우연 응집도가 존재한다.

## SRP, 단일 책임 원칙

>   어떤 클래스를 변경해야 하는 이유는 오직 하나 뿐이어야 한다.

단일 책임 원칙은 속성, 메소드, 클래스, 패키지, 모듈, 컴포넌트, 프레임워크 등에 적용할 수 있는 개념이다.

클래스를 예로 들어서 살펴보면, 클래스를 역할과 책임에 따라 분리해서 각각 하나의 역할과 책임만 가지게 하는 것이다.
남자라는 클래스가 존재할 때 어머니-남자, 직장상사-남자와 같이 역할과 책임이 몰려있도록 구현하는 것이 아닌 각 역할에 맞게 어머니-아들 관계, 직장상사-사원 관계 등과 같이 역할과 책임에 따라 여러 개의 클래스로 쪼개서 구현하는 것이다.

잘못된 경우를 살펴보는 것이 이해하기 쉽다.

속성이 단일 책임 원칙을 지키지 못하는 경우가 있다. 남자와 여자 클래스로 구분하지 않고 사람이라는 하나의 클래스로 구현하였을 경우가 있다. 남자에게만 있는 속성과 여자에게만 있는 속성이 있을텐데, 그를 구분하지 않고 하나의 클래스로 구현하면 문제가 발생한다. 이러한 경우 남자 클래스와 여자 클래스로 구분하여 구현한다.

또 하나의 속성이 여러 의미를 가지는 경우도 단일 책임 원칙을 지키지 못하는 경우다. DB 테이블에 존재하는 하나의 필드가 토지인 경우 면적을, 건물인 경우 층수를 나타내는 경우와 같다. 이러한 경우 자바 코드에서는 if문을 여기저기 사용해야 한다. 클래스가 아닌 DB 테이블이긴 하지만 DB 테이블을 설계할 때도 단일 책임 원칙을 고려해야 한다.

메소드가 SRP를 지키지 못하는 경우는 다음과 같다. 위에서 언급한 것과 같이 남자와 여자를 사람 클래스에서 구분할 때 사람 클래스의 메소드에서 if문으로 남자인지 여자인지를 판별하는 경우가 있다. 해당 메소드가 남자와 여자의 행위를 모두 구현하려고 하기에 SRP를 위배한다. 이렇듯 메소드가 SRP를 지키지 않을 경우 나타나는 대표적인 특징이 분기 처리를 위한 if문이다. 이 경우 사람 클래스를 상속받는 남자 클래스와 여자 클래스의 각각의 행위 메소드를 활용하도록 리팩토링한다.