# Transaction

## 정의

**데이터베이스 관리 시스템 또는 유사한 시스템에서 상호작용의 단위**이다. 유사한 시스템이란, 트랜잭션이 성공과 실패가 분명하고 상호 독립적이며 일관되고 믿을 수 있는 시스템을 의미한다. (위키백과)

**데이터베이스의 상태를 변화시키기 위해 수행하는 작업의 단위**를 의미한다. (Mommoo 블로그)
작업 단위는 많은 질의어 명령문들을 사람이 정하는 기준에 따라 정하는 것을 의미한다. 

**데이터베이스의 상태를 변환시키는 하나의 논리적 기능을 수행하기 위한 작업의 단위 또는 한꺼번에 모두 수행되어야 할 일련의 연산들**을 의미한다.
데이터베이스 시스템에서 병행 제어 및 회복 작업 시 처리되는 작업의 논리적 단위이며 사용자가 시스템에 대한 서비스 요구 시 시스템이 응답하기 위한 상태 변환 과정의 작업단위이다. 하나의 트랜잭션은 Commit되거나 Rollback된다. (코딩팩토리)

## 목적

데이터베이스 기능 중, 트랜잭션을 조작하는 기능은 사용자가 데이터베이스 완전성(Integrity) 유지를 확신하게 한다.

단일 트랜잭션은 데이터베이스 내에 읽거나 쓰는 여러 개 쿼리를 요구한다. 이 때 중요한 것은 데이터베이스가 수행된 일부 쿼리가 남지 않는 것이다.
예를 들어, 송금을 할 때 한 계좌에서 인출되면 다른 계좌에서 입금이 확인되는 것이 중요하다.
또한 트랜잭션은 서로 간섭하지 않아야 한다. 

만약 쿼리 하나가 실패하면, 데이터베이스 시스템은 전체 트랜잭션 또는 실패한 쿼리를 롤백한다. 이것은 DBMS가 어떻게 사용되고 셋업 되었느냐에 따라 다르다. 트랜잭션은 커밋전에 언제든지 수동으로 롤백될 수 있다.

## 성질, ACID

이론적으로 데이터베이스 시스템은 각각의 트랜잭션에 대해 **원자성(Atomicity), 일관성(Consistency), 독립성(Isolation), 영구성(Durability)**를 보장한다. 이 성질을 **ACID**라 부른다. 하지만 실제로는 성능향상을 위해 이런 특성들이 종종 완화되곤 한다.
어떤 시스템들에서는 트랜잭션들은 논리적 작업 단위(LUW, Logical Units of Work)로 불린다.

*   **원자성, Atomicity**
    <u>트랜잭션과 관련된 작업들이 부분적으로 실행되다가 중단되지 않는 것을 보장하는 능력이다.</u>
    예를 들어, 자금 이체는 성공할 수도 실패할 수도 있지만 보내는 쪽에서 돈을 빼 오는 작업만 성공하고 받는 쪽에 돈을 넣는 작업을 실패해서는 안된다. 원자성은 이와 같이 중간 단계까지 실행되고 실패하는 일이 없도록 하는 것이다.
    <u>트랜잭션이 데이터베이스에 모두 반영되던가, 아니면 전혀 반영되지 않아야 한다는 것이다.</u>
*   **일관성, Consistency**
    <u>트랜잭션이 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 유지하는 것을 의미한다.</u>
    무결성 제약이 모든 계좌는 잔고가 있어야 한다면 이를 위반하는 트랜잭션은 중단된다.
*   **독립성, Isolation**
    <u>트랜잭션을 수행 시 다른 트랜잭션의 연산 작업이 끼어들지 못하도록 보장하는 것을 의미한다.</u>
    트랜잭션 밖에 있는 어떤 연산도 중간 단계의 데이터를 볼 수 없음을 의미한다. 은행 관리자는 이체 작업을 하는 도중에 쿼리를 실행하더라도 특정 계좌간 이체하는 양 쪽을 볼 수 없다. 공식적으로 고립성은 트랜잭션 실행내역은 연속적이어야 함을 의미한다. 성능관련 이유로 인해 이 특성은 가장 유연성 있는 제약 조건이다.
*   **지속성, Durability**
    <u>성공적으로 수행된 트랜잭션은 영원히 반영되어야 함을 의미한다.</u>
    시스템 문제, DB 일관성 체크 등을 하더라도 유지되어야 함을 의미한다. 전형적으로 모든 트랜잭션은 로그로 남고 시스템 장애 발생 전 상태로 되돌릴 수 있다. 트랜잭션은 로그에 모든 것이 저장된 후에만 Commit 상태로 간주될 수 있다.

### ACID를 보장하는 방법

*   **원자성 보장**
    트랜잭션에서 원자성은 <u>수행하고 있는 트랜잭션에 의해 변경된 내역을 유지하면서 이전에 Commit된 상태를 임시 영역에 따로 저장함</u>으로써 보장한다. 현재 수행하고 있는 트랜잭션에서 오류가 발생하면 현재 내역을 날려버리고 임시 영역에 저장했던 상태로 Rollback한다.

    이전 데이터들이 임시로 저장되는 영역을 **롤백 세그먼트(Rollback Segment)**라고 하며, 현재 수행하고 있는 트랜잭션에 의해 새롭게 변경되는 내역을 **데이터베이스 테이블**이라고 한다. 트랜잭션의 원자성은 롤백 세그먼트에 의해 보장된다

    트랜잭션의 길이가 길 경우 오류가 발생하여 Rollback하게되면 오류가 발생하지 않은 부분도 다시 처음부터 작업을 수행해야 할 수 있다. 이러한 경우를 방지하기 위해 Rollback되지 않도록 **save point**를 지정할 수 있다. save point를 지정하면 rollback할 때 그 이전은 확실하다 간주하고 그 이후부터 진행하게 된다. 

*   **일관성 보장**
    트랜잭션에서 일관성은 <u>트랜잭션 수행 전, 후에 데이터 모델의 모든 제약조건(PK, FK, 도메인, 도메인 제약조건 등)을 만족하는 것</u>을 통해 보장한다.
    어느 테이블의 PK의 제약조건이 변경되면, 해당 PK를 FK로 가지는 다른 테이블에서도 FK의 제약조건이 변경되어야 한다는 것이다.

    어떤 이벤트와 조건이 발생했을 때, **트리거(Trigger)**를 통해 일관성을 보장한다.
    트리거는 데이터베이스 시스템이 자동적으로 수행할 동작을 명시하는데 사용된다.

*   **독립성 보장**
    병행 트랜잭션에 대한 이해가 필요하다.
    **병행 처리(Concurrent Processing)**이란, <u>CPU가 여러 프로세스를 처리하는 것처럼 트랜잭션에 정해진 시간을 할당해서 작업을 하다가 부여된 시간이 끝나면 다른 트랜잭션을 실행하는 방식으로 트랜잭션들을 조금씩 처리하는 것</u>을 의미한다. 이렇게 되면 트랜잭션들이 조금씩 처리되는 과정에서 공통된 데이터를 조작하게 되는데, 이와 같이 트랜잭션의 간섭이 일어날 경우 <u>갱신분실, 오손판독, 반복불가능, 팬텀문제</u> 등의 문제점들이 발생한다.

    트랜잭션에서 독립성은 **Lock & Excute unlock**을 통해 보장한다. 이는 OS의 세마포어(Semaphore)와 비슷한 개념이다.
    <u>데이터를 읽거나 쓸 때는 문을 잠궈서 다른 트랜잭션들이 접근하지 못하도록 독립성을 보장하고, 수행을 마치면 unlock을 통해 데이터를 다른 트랜잭션이 접근할 수 있도록 허용하는 방식</u>이다.
    트랜잭션에서 데이터를 읽을 때, 여러 트랜잭션이 읽을수는 있도록 허용하는 **shared_lock**을 한다. 그리고 데이터를 쓸 때는 다른 트랜잭션이 읽을수도 쓸 수도 없게 하는 **exclusive_lock**을 사용한다. 읽기, 쓰기 작업이 끝나면 **unlock**을 통해 다른 트랜잭션이 lock을 할 수 있도록 데이터에 대한 잠금을 풀어준다. 그런데 이를 잘못사용하면 **deadlock** 상태 즉, <u>모든 트랜잭션이 아무것도 수행할 수 없는 상태</u>가 될 수 있다.

    데드락 상태가 되면 안되므로 어떤 규칙에 의해서 독립성을 보장해야 한다는 **2PL 프로토콜**이 연구되었다.
    이는 <u>여러 트랜잭션이 공유하고 있는 데이터에 동시에 접근할 수 없도록 하기위한 프로토콜</u>이다. 이름 그대로 2가지 단계의 locking이 존재하는데, **Growing phase의 read_lock, write_lock과 shrinking phase의 unlock**이다.
    2PL 프로토콜은 상승 단계와 하강 단계가 섞이면 안된다는 것을 의미한다. 즉, <u>lock과 unlock이 번갈아 수행되지 않고 lock이 전부 수행된 이후에 unlock이 쭉 수행되는 것</u>이다.

    정리하면, **성능을 위해 병행처리를 해야하는데 트랜잭션의 독립성을 보장하기 위해서는 2PL 프로토콜을 사용해야 한다는 것**이다.

ACID는 DB의 모든 연산이 한번에 실행되는 것을 권장한다.
널리 사용하는 두 가지 방법이 있는데 **로깅방식**과 **섀도우 페이징**이다. 두 경우 모두 업데이트되는 데이터에 락을 거는 것이 필요하다. 로깅방식에서 <u>원자성은 DB에 데이터를 업데이트 하기 전에 로그에 모든 변경사항을 기록하는 것으로 보장</u>된다. 이것은 충돌 현상이 발생하더라도 DB 무결성을 보장해준다. 섀도우 페이징 방식은 <u>변경이 DB의 복사본에 저장</u>된다. 그리고 새로운 복사본은 트랜잭션이 Commit되면 활성화된다. 복사본은 변경 전 데이터 부분만을 의미한다

최근까지 DB들은 대부분 ACID를 보장하기 위해 락에 의존했다. 이것은 데이터 처리전에 언제나 락이 필요함을 의미한다. 많은 수의 락을 관리하게 되면 동시작업 수행이 어렵고 성능저하를 초래하게 된다. A유저가 특정 테이블을 읽고 있다면 B유저는 A의 트랜잭션이 끝나기를 기다려야 한다. 

락의 대안으로 수정되는 모든 데이터를 **별도 복사본으로 관리하는 MVCC(다중 버전 동시성 제어)**가 있다. 방금 전 언급한 A, B 유저의 예를 들면 A가 트랜잭션을 시작할 때 가지고 있던 복사본을 B에 제공하여 동시에 수행이 가능하다. 이 방식은 사용자들이 데이터 처리하는데 있어 많은 유연성을 제공한다.

네트워크 환경에서 ACID 특성을 보장하는 것은 어렵다. 연결이 끊길 수도 있고 두 사용자가 동시에 DB의 동일한 부분을 접근할 수도 있다.

트랜잭션의 Commit 여부를 각 사용자로부터 확인하기 위해 2단계 Commit이 분산 트랜잭션에 적용된다. 트랜잭션이 병렬 수행되는 경우 많은 주의가 필요하다. 2단계 락은 완전한 독립성을 보장하기 위해 사용된다.

## 연산

*   **Commit** 
    <u>하나의 트랜잭션이 성공적으로 끝났고, 데이터베이스가 일관성있는 상태에 있을 때, 하나의 트랜잭션이 끝났다라는 것을 알려주기 위해 사용하는 연산이다.</u> 이 연산을 사용하면 수행했던 트랜잭션이 로그에 저장되며, 후에 Rollback 연산을 수행했었던 트랜잭션 단위로 하는 것을 도와준다.

*   **Rollback**
    하나의 트랜잭션 처리가 비정상적으로 종료되어 트랜잭션의 원자성이 깨진경우, 트랜잭션을 처음부터 다시 시작하거나, 트랜잭션의 부분적으로만 연산된 결과를 다시 취소시킨다. 후에 사용자가 트랜잭션 처리된 단위대로 Rollback을 진행할 수도 있다.
    Rollback시에는 해당 트랜잭션을 재시작하거나 폐기한다.

## 상태

<img src="/Users/user/Documents/TIL/Database/images/image-20210125112051451.png" alt="image-20210125112051451" style="zoom: 50%;" />

*   **활동, Active**
    트랜잭션이 실행중인 상태
*   **실패, Failed**
    트랜잭션 실행에 오류가 발생하여 중단된 상태
*   **철회, Aborted**
    트랜잭션이 비정상적으로 종료되어 Rollback 연산을 수행한 상태
*   **부분 완료, Partially Committed**
    트랜잭션의 마지막 연산까지 실행했지만, Commit 연산이 실행되기 직전의 상태
*   **완료, Committed**
    트랜잭션이 성공적으로 종료되어 Commit 연산을 실행한 후의 상태

# 참고

*   [위키백과, ACID](https://ko.wikipedia.org/wiki/ACID)
*   [위키백과, 데이터베이스 트랜잭션](https://ko.wikipedia.org/wiki/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4_%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98)
*   [트랜잭션이란?, mommoo님 블로그](https://mommoo.tistory.com/62)
*   [트랜잭션이란 무엇인가?, 코딩팩토리](https://coding-factory.tistory.com/226#recentEntries)
*   [트랜잭션과 ACID를 보장하는 방법, victolee님 블로그](https://victorydntmd.tistory.com/129)