# Stack

## 개념

* 프로그램에서 중요성과 활용도가 매우 높은 자료구조
* 물건을 쌓아 올리듯 자료를 쌓아 올린 형태의 자료구조
* Stack에 저장된 자료는 선형 구조를 가짐
  * 선형구조 : 자료간의 관계가 1대1의 관계를 가짐
* Stack에 자료를 삽입하거나 Stack에서 자료를 꺼내는 연산이 있음
* Stack에서 마지막에 삽입한 자료가 가장 먼저 꺼내어짐
  * 후입선출(LIFO, Last-In-First-Out)

### 구현

* 자료를 선형으로 저장할 저장소가 필요함
  * C언어에서는 배열을 사용, 저장소 자체를 Stack이라 부르기도함
  * Stack에서 마지막에 삽입된 원소의 위치를 top이라 부름
* 연산
  * 삽입 : 저장소에 자료를 저장하고 보통 push라고 부름
  * 삭제
    * 저장소에서 자료를 꺼냄
    * 꺼낸 자료는 삽입한 자료의 역순으로 꺼냄
    * 보통 pop이라 부름
  * isEmpty : Stack이 공백인지 아닌지를 확인하는 연산
  * peek : Stack의 top에 있는 item(원소)을 반환하는 연산

### 연산

> 빈 Stack에 원소 A, B, C를 차례로 삽입 후 한 번 삭제하는 연산 과정

* 공백 Stack에서 top은 -1
* push A의 연산결과로 Stack의 top이 A 자리를 가리킴
* push B의 연산결과로 Stack에 B가 삽입되고 top이 B 자리를 가리킴
* push C의 연산결과로 Stack에 C가 삽입되고 top이 C 자리를 가리킴
  * 이 때 A, B, C 순서대로 바닥부터 쌓여있음
* pop 연산 결과로 C가 삭제되고 top이 B 자리를 가리킴

#### Push

* top이 1 증가
* 증가된 top이 Stack Size보다 크다면 Overflow처리
* 그렇지 않다면 Stack에서 top의 자리에 자료를 저장

#### Pop

* top이 0이라면 공백 Stack을 의미하며 Underflow 처리
* 그렇지 않다면 top의 값을 반환하고 top을 1 감소시킴

### 구현시 고려사항

* 1차원 배열을 사용하여 구현
  * 장점 : 구현이 용이함
  * 단점 : Stack의 크기를 변경하기가 어려움
* 저장소를 동적으로 할당하여 Stack을 구현
  * 동적 연결리스트를 이용하여 구현하는 방법
  * 장점 : 메모리를 효율적으로 사용
  * 단점 : 1차원 배열로 구현하는 것보다 구현이 복잡

## 응용

### 괄호검사

* 괄호의 종류
  * 대괄호 `[ ]`
  * 중괄호 `{ } `
  * 소괄호 `( )`
* 조건
  * 왼쪽 과호의 개수와 오른쪽 괄호의 개수가 같아야함
  * 같은 괄호에서 왼쪽 괄호는 오른쪽 괄호보다 먼저 나와야함
  * 괄호 사이에는 포함 관계만 존재함
* 문자열에 있는 괄호를 차례대로 조사
  * 왼쪽 괄호를 만나면 Stack에 삽입
  * 오른쪽 괄호를 만나면 Stack에서 top 괄호를 삭제한 후 오른쪽 괄호와 짝이 맞는지 확인
    * Stack이 비어있음 : 조건 1 또는 조건 2에 위배
    * 괄호의 짝이 맞지 않음 : 조건 3에 위배
    * 문자열 끝까지 조사한 후에도 Stack에 괄호가 남아있음 : 조건 1에 위배
    * 조건
      1. 왼쪽 괄호의 개수와 오른쪽 괄호의 개수가 같아야 함
      2. 같은 괄호에서 왼쪽 괄호는 오른쪽 괄호보다 먼저 나와야 함
      3. 괄호 사이에는 포함 관계만 존재함

### Function Call

* 프로그램에서의 함수 호출과 복귀에 따른 수행 순서를 관리
  * 가장 마지막에 호출된 함수가 가장 먼저 실행을 완료하고 복귀하는 후입선출 구조이므로, 후입선출 구조의 Stack을 이용하여 수행순서 관리
  * 함수 호출이 발생하면 호출한 함수 수행에 필요한 지역변수, 매개변수 및 수행 후 복귀할 주소 등의 정보를 Stack 프레임에 저장하여 시스템 Stack에 삽입
  * 함수의 실행이 끝나면 시스템 Stack의 top원소(Stack 프레임)를 삭제(pop)하면서 프레임에 저장되어있던 복귀주소를 확인하고 복귀
  * 함수 호출과 복귀에 따라 이 과정을 반복하여 전체 프로그램 수행이 종료되면 시스템 Stack은 공백 Stack이 됨
* 프로그램 메모리 공간
  * 코드 영역
    * 실행할 프로그램의 코드가 저장되는 메모리 공간
    * CPU는 코드 영역에 저장된 명령문을 하나씩 가져다가 실행
  * 데이터 영역
    * 전역변수와 static 변수가 할당되는 영역
    * 프로그램 시작과 동시에 할당되어 종료 시까지 남아있는 특징의 변수가 저장되는 영역
  * 힙 영역
    * 프로그래머가 원하는 시점에 메모리 공간에 할당 및 소멸을 하기 위한 영역
  * Stack 영역
    * 지역변수와 매개변수가 할당되는 영역
    * 함수를 빠져나가면 소멸되는 변수를 저장하는 영역
* 재귀 호출
  * 자기 자신을 호출하여 순환 수행되는 것
  * 함수에서 실행해야 하는 작업의 특성에 따라 일반적인 호출방식보다 재귀 호출방식을 사용하여 함수를 만들면 프로그램의 크기를 줄이고 간단하게 작성할 수 있음
  * 디버깅이 어렵고 잘못 작성하게 되면 수행 시간이 많이 소요됨

## Memoization

* 컴퓨터 프로그램을 실행할 때 이전에 계산한 값을 메모리에 저장해서 매번 다시 계산하지 않도록 하여 전체적인 실행속도를 빠르게 하는 기술
* DP(동적 계획)의 핵심이 되는 기술

### 피보나치 수열

* 0과 1로 시작하고 이전의 두 수 합을 다음 항으로 하는 수열
* 엄청난 중복호출이 존재한다는 문제점
  * Memoization을 적용하여 해결가능

## DP

> 동적 계획법

### 개념

* 그리디 알고리즘 설계 기법과 같이 최적화 문제를 해결하는 알고리즘 설계기법
* 먼저 입력크기가 작은 부분 문제들을 모두 해결한 후에 그 해들을 이용하여 보다 큰 크기의 부분문제들을 해겨하고 최종적으로 원래 주어진 입력의 문제를 해결하는 바법

### 피보나치 수에 적용

* 부분 문제의 답으로부터 본 문제의 답을 얻을 수 있는 최적부분 문제

1. 문제를 부분 문제로 분할
2. 부분 문제로 나누는 일을 끝냈으면 가장 작은 부분 문제부터 해를 구함
3. 그 결과는 테이블에 저장하고 테이블에 저장된 부분 문제의 해를 이용하여 상위 문제의 해를 구함

### DP의 구현방식

* Recursive 방식
  * 재귀적 구조는 내부에 시스템 호출 Stack을 사용하는 Overhead가 발생할 수 있음
* Iterative 방식
  * Memoization을 재귀적 구조에 사용하는 것보다 반복적 구조로 DP를 구현한 것이 성능면에서 보다 효율적

## DFS

> 깊이 우선 탐색

### 개념

* 시작 정점의 한 방향으로 갈 수 있는 경로가 있는 곳까지 깊이 탐색
* 더 이상 갈곳이 없게 되면, 가장 마지막에 만났던 갈림길 간선이 있는 정점으로 되돌아옴
* 다른 방향의 정점으로 탐색을 계속 반복하여 결국 모든 정점을 방문하여 순회
* 가장 마지막에 만났던 갈림길의 정점으로 돌아가서 다시 깊이 우선탐색을 반복해야 하므로 후입선출 구조의 Stack을 사용하여 알고리즘을 구현

### 알고리즘

1. 시작 정점 V를 결정하여 방문
2. 방문하지 않은 정점 W가 있으면 정점 V를 Stack에 push하고 정점 W를 방문
3. W를 V로 하여 다시 1번부터 반복
4. 방문하지 않은 정점이 없으면 탐색의 방향을 바꾸기 위해서 Stack을 pop하여 받은 가장 마지막 방문 정점을 V로 하여 다시 1번부터 반복
5. Stack이 공백이 될때까지 알고리즘을 반복

## 계산기

* 문자열로 계산식이 주어질 때, Stack을 이용하여 결과값을 계산할 수 있다.

* 문자열 수식 계산

  * Stack을 이용하여 중위표기법의 수식을 후위표기법으로 변경
    * 중위표기법 : 연산자를 피연산자의 가운데 표기하는 방법 (A+B)
  * 후위표기법의 수식을 Stack을 이용하여 계산
    * 후위표기법 : 연산자를 피연산자 뒤에 표기하는 방법(AB+)

* 중위표기식의 후위표기식 변환방법

  * 수식의 각 연산자에 대해서 우선순위에 따라 괄호를 사용하여 다시표현
  * 각 연산자를 그에 대응하는 오른쪽 괄호의 뒤로 이동
  * 괄호 제거
  * 사람이 손으로 처리하기는 쉽지만 프로그램으로 작성하기 어려움
    * 중위표기식을 후위표기식으로 변환하는 알고리즘이 개발됨
      1. 입력받은 중위표기식에서 토큰을 읽음
      2. 토큰이 피연산자이면 토큰을 출력
      3. 토큰이 연산자(괄호포함)일 경우
         * 우선순위가 높으면 Stack에 push
         * 우선순위가 안 높으면 연산자의 우선순위가 토큰의 우선순위보다 작을 때까지 Stack에서 pop한 후 토큰의 연산자를 push
         * top에 연산자가 없다면 push
      4. 토큰이 오른쪽 괄호인 경우
         * Stack top에 왼쪽 괄호가 올 때까지 Stack pop연산을 수행
         * pop한 연산자를 출력
         * 왼쪽 괄호를 만나면 pop만 하고 출력하지는 않음
      5. 중위 표기식에 더 읽을 것이 없다면 중지, 더 읽을 것이 있다면 1번부터 반복
      6. Stackdp 남아 있는 연산자를 모두 pop하여 출력
         * Stack 밖의 왼쪽 괄호는 우선순위가 가장 높으며 Stack 안의 왼쪽 괄호는 우선순위가 가장 낮음
    * 예시
      * 중위 : (6 + 5 * (2 - 8) / 2)
      * 후위 : 6 5 2 8 - * 2 / +

* 후위표기법의 수식을 Stack을 이용하여 계산

  1. 피연산자를 만나면 Stack에 push
  2. 연산자를 만나면 필요한 만큼의 피연산자를 stack에서 pop하여 연산하고, 연산결과를 다시 Stack에 push
  3. 수식이 끝나면 마지막으로 Stack을 pop하여 계산완료

  * 주의 : 후위표기식을 계산할 때는 피연산자를 Stack에 쌓아 계산
    		   먼저 들어간 Stack값이 앞에 온다는 것을 생각.