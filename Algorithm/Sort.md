# Sort

> 2개 이상의 자료를 특정 기준에 의해 작은 값부터 큰 값(오름차순 : ascending), 혹은 그 반대의 순서대로(내림차순 : descending) 재배열 하는 것

* Key : 정렬하는 기준이 되는 특정 값

* Sort 방식

  * Bubble Sort (버블 정렬)
  * Counting Sort (카운팅 정렬)
  * Selection Sort (선택 정렬)
  * Quick Sort (퀵 정렬)
  * Insertion Sort (삽입 정렬)
  * Merge Sort (병합 정렬)

  | 알고리즘    | 평균 수행시간 | 최악 수행시간 | 알고리즘 기법 | 비고                                               |
  | ----------- | ------------- | ------------- | ------------- | -------------------------------------------------- |
  | 버블 정렬   | O(n제곱)      | O(n제곱)      | 비교와 교환   | 코딩이 가장 쉬움                                   |
  | 카운팅 정렬 | O(n + k)      | O(n + k)      | 비교환 방식   | n이 비교적 작을 때만 가능                          |
  | 선택 정렬   | O(n제곱)      | O(n제곱)      | 비교와 교환   | 교환의 회수가 버블, <br />삽입정렬보다 작음        |
  | 퀵 정렬     | O(n logn)     | O(n제곱)      | 분할 정복     | 최악의 경우 n제곱이지만 <br />평균적으로 가장 빠름 |
  | 삽입 정렬   | O(n제곱)      | O(n제곱)      | 비교와 교환   | n의 개수가 작을 때 효과적                          |
  | 병합 정렬   | O(n logn)     | O(n logn)     | 분할 정복     | 연결리스트의 경우 가장 효율적인 방식               |

## Bubble Sort

> 인접한 두 개의 원소를 비교하며 자리를 계속 교환하는 방식

* 정렬과정
  * 첫 번째 원소부터 인접한 원소끼리 계속 자리를 교환하면서 맨 마지막 자리까지 이동
  * 한 단계가 끝나면 가장 큰 원소 또는 가장 작은 원소가 마지막 자리로 정렬됨
* 교환하여 자리를 이동하는 모습이 물 위에 올라오는 거품모양과 같다고 하여 Bubble Sort
* 시간복잡도
  * O(n제곱)
* 예시
  * 55, 8, 78, 12, 42를 Bubble Sort 하는 과정
    1. 55, 7, 78, 12, 42
    2. 7, 55, 78, 12, 42
    3. 7, 55, 78, 12, 42
    4. 7, 55, 12, 78, 42
    5. 7, 55, 12, 42, 78
    6. 7, 55, 12, 42, 78
    7. 7, 12, 55, 42, 78
    8. 7, 12, 42, 55, 78
  * 가장 마지막 부분부터 정렬이 완료되고 나머지 범위에서 정렬을 반복한다.

## Counting Sort

> 항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 세는 작업을 하여, 선형 시간에 정렬하는 효율적인 Algorithm

* 제한사항
  * 정수나 정수로 표현할 수 있는 자료에 대해서만 적용 가능
    * 각 항목의 발생 회수를 기록하기 위해, 정수 항목으로 인덱스되는 카운트들의 배열을 사용하기 때문
  * 카운트들을 위한 충분한 공간을 할당하려면 집합 내의 가장 큰 정수를 알아야 함
* 시간 복잡도
  * O(n + k) : n은 항목의 개수, k는 정수의 최대값
* 예시
  * 0, 4, 1, 3, 1, 2, 4, 1을 정렬하는 과정
    1. Data에서 각 항목들의 발생 횟수를 세고, 정수 항목들로 직접 인덱스 되는 카운트 배열 COUNTS에 저장
       * COUNTS = {1, 3, 1, 1, 2}
    2. 정렬된 집합에서 각 항목의 앞에 위치할 항목의 개수를 반영하기 위해 COUNTS의 원소를 조정
       * COUNTS = {1, 4, 5, 6, 8}
       * 해당 원소가 정렬될 때 배열의 몇 번째 위치에 들어가야 하는지를 보여줌
    3. COUNTS[1]을 감소시키고 TEMP에 1을 삽입
       * COUNTS[1]의 값이 4임을 확인하고 TEMP[4]에 1을 삽입하고 COUNTS[1]을 3으로 줄임
    4. 같은 방식으로 Data 배열을 전부 진행