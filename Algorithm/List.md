# List

## List

### List의 특성

* 순서를 가진 데이터의 집합을 가리키는 추상자료형(abstract data type)
  * 동일한 데이터를 가지고 있어도 상관 없음
  * 구현 방법에 따라 크게 두 가지로 나뉨
    * 순차 List : 배열을 기반으로 구현된 List
    * 연결 List : 메모리의 동적할당을 기반으로 구현된 List

### List의 주요함수

* `addtoFirst()`
  * List의 앞쪽에 원소를 추가하는 연산
* `addtoLast()`
  * List의 뒤쪽에 원소를 추가하는 연산
* `add()`
  * List의 특정 위치에 원소를 추가하는 연산
* `delete()`
  * List의 특정 위치에 있는 원소를 삭제하는 연산
* `get()`
  * List의 특정 위치에 있는 원소를 리턴하는 연산

### 순차 List

#### 구현방법

1. 1차원 배열에 항목들을 순서대로 저장
2. 데이터의 종류와 구조에 따라 구조화된 자료구조를 만들어 배열로 구현할 수도 있음

#### 데이터 접근

* 배열의 인덱스를 이용해 원하는 위치의 데이터에 접근할 수 있음

#### 삽입 연산

* 삽입 위치 다음의 항목들을 이동해야 함
  * 이동하는 순서에 주의, 5번째가 이동후 4번째가 이동해야함

#### 삭제 연산

* 삭제 위치 다음의 항목들을 이동해야 함
  * 이동 순서에 주의, 3번째가 이동하고 4번째가 이동해야함

#### 단순 배열을 이용한 구현의 단점

* 자료의 삽입/삭제 연산 과정에서 연속적인 메모리 배열을 위해 원소들을 이동시키는 작업이 필요함
* 원소의 개수가 많고 삽입/삭제 연산이 빈번하게 일어날수록 작업에 소요되는 시간이 크게 증가
* 배열의 크기가 정해져 있는 경우, 실제로 사용될 메모리보다 크게 할당하여 메모리의 낭비를 초래할 수 있고, 반대로 할당된 메모리보다 많은 자료를 사용하여 새롭게 배열을 만들어 작업을 해야하는 경우가 발생할 수 있음

### 연결 List

* 단순 배열을 이용한 순차 List의 단점을 보완한 자료구조
* 자료의 논리적인 순서와 메모리 상의 물리적인 순서가 일치하지 않고, 개별적으로 위치하고 있는 원소의 주소를 연결하여 하나의 전체적인 자료구조를 이룸
* 링크를 통해 원소에 접근하므로, 순차 List에서 물리적인 순서를 맞추기위한 작업이 필요하지 않음
* 자료구조의 크기를 동적으로 조정할 수 있어, 메모리의 효율적인 사용이 가능
* 단점
  * 구현이 배열 List보다 어려움

#### 노드

* 구성
  * 노드
    * 연결 List에서 하나의 원소에 필요한 데이터를 갖고 있는 자료단위
    * 데이터 필드
      * 원소의 값을 저장하는 자료구조
      * 저장할 원소의 종류나 크기에 따라 구조를 정의하여 사용함
    * 링크 필드
      * 다음 노드의 주소를 저장하는 자료구조
  * 헤드
    * List의 처음 노드를 가리키는 자료구조
    * 헤드 자체에는 데이터가 저장되지 않음

#### 단순 연결 List

* 노드가 하나의 링크 필드에 의해 다음 노드와 연결되는 구조를 가짐
* 헤드가 가장 앞의 노드를 가리키고, 링크 필드가 연속적으로 다음 노드를 가리킴
* 최종적으로 NULL을 가리키는 노드가 List의 마지막 노드가 됨
* 삽입 연산
  * A, C, D를 원소로 갖고 있는 List의 두 번째에 B노드를 삽입할 때
    1. 메모리를 할당하여 새로운 노드 new 생성
    2. 새로운 노드 new의 데이터 필드에 B 저장
    3. 삽입될 위치의 바로 앞에 위치한 노드의 링크필드를 new에 복사
    4. new의 주소를 앞 노드의 링크필드에 저장
  * List의 처음 위치에 노드를 삽입하는 알고리즘
    1. 새로운 노드 생성
    2. 데이터 필드 작성
    3. 링크 필드 작성
    4. List의 처음으로 지정
* 삭제 연산
  * A, B, C, D List의 B 노드를 삭제할 때
    1. 삭제할 노드의 앞 노드(선행노드) 탐색
    2. 삭제할 노드의 링크 필드를 선행노드의 링크필드에 복사

#### 이중 연결 List

* 양쪽 방향으로 순회할 수 있도록 노드를 연결한 List
* 두 개의 링크 필드와 한 개의 데이터 필드로 구성
* 삽입 연산
  * cur이 가리키는 노드 다음으로 D 값을 가진 노드를 삽입하는 과정
    1. 메모리를 할당하여 새로운 노드 new를 생성하고 데이터 필드에 D를 저장
    2. cur의 next를 new의 next에 저장하여 cur의 다음 노드를 삽입할 노드의 다음 노드로 연결
    3. new의 값을 cur의 next에 저장하여 삽입할 노드를 ucur의 다음 노드로 연결
    4. cur의 값을 new의 prev필드에 저장하여 cur을 new의 이전 노드로 연결
    5. new의 값을 new가 가리키는 노드의 다음 노드의 prev필드에 저장하여 삽입하려는 노드의 다음 노드와 삽입하려는 노드를 연결
* 삭제 연산
  * cur이 가리키는 노드를 삭제하는 과정
    1. 삭제할 노드의 다음 노드의 주소를 삭제할 노드의 이전 노드의 next필드에 저장하여 링크를 연결
    2. 삭제할 노드의 다음 노드의 prev필드에 삭제할 노드의 이전 노드의 주소를 저장하여 링크를 연결
    3. cur이 가리키는 노드에 할당된 메모리를 반환

## 삽입 정렬

### 특징

* 도서관 사서가 책을 정렬할 때, 일반적으로 활용되는 방식
* 자료 배열의 모든 원소들을 앞에서부터 차례대로 이미 정렬된 부분과 비교하여, 자신의 위치를 찾아냄으로써 정렬을 완성
* 정렬과정
  1. 정렬할 자료를 두 개의 부분집합 S와 U로 가정
     * 부분집합 S : 정렬된 앞부분의 원소들
     * 부분집합 U : 아직 정렬되지 않은 나머지 원소들
  2. 정렬되지 않은 부분집합 U의 원소를 하나씩 꺼내서 이미 정렬되어있는 부분집합 S의 마지막 원소부터 비교하면서 위치를 찾아 삽입
  3. 2의 과정을 반복하면서 부분집합 S의 원소는 하나씩 늘리고 부분집합 U의 원소는 하나씩 감소하게 함
  4. 부분집합 U가 공집합이 되면 삽입정렬이 완성

## 병합 정렬

### 특징

* 여러 개의 정렬된 자료의 집합을 병합하여 한 개의 정렬된 집합으로 만드는 방식
* 분할 정복 알고리즘 활용
  * 자료를 최소 단위의 문제까지 나눈 후에 차례대로 정렬하여 최종 결과를 얻어냄
  * Top-Down 방식
* 시간 복잡도
  * O(n logn)

### 과정

* 69, 10, 30, 2, 16, 8, 31, 22를 병합 정렬하는 과정
  1. 분할 단계
     * 전체 자료 집합에 대하여, 최소 크기의 부분집합이 될 때까지 분할 작업을 계속함
  2. 병합 단계
     * 2개의 부분집합을 정렬하면서 하나의 집합으로 병합

## 활용

### Stack

* Stack의 원소 = List의 노드
  * Stack 내의 순서는 List의 링크를 통해 연결됨
  * Push : List의 마지막에 노드 삽입
  * Pop : List의 마지막 노드 반환/삭제
* 변수 Top
  * List의 마지막 노드를 가리키는 변수
  * 초기상태의 Top = null

### 우선순위 Queue

* 배열이나 List를 이용하여 구현할 수 있음
* 기본연산으로 삽입과 삭제 연산이 존재
* 배열을 이용한 우선순위 Queue 구현
  * 구현
    * 배열을 이용하여 자료 저장
    * 원소를 삽입하는 과정에서 우선순위를 비교하여 적절한 위치에 삽입하는 구조
    * 가장 앞에 최고 우선순위의 원소가 위치하게 됨
  * 문제점
    * 배열을 사용하므로, 삽입이나 삭제 연산이 일어날 때, 원소의 재배치가 발생함
    * 이것에 소요되는 시간이나 메모리 낭비가 큼
* List를 이용한 우선순위 Queue 구현
  * 구현
    * 연결 List를 이용하여 자료 저장
    * 원소를 삽입하는 과정에서 List 내 노드의 원소들과 비교하여 적절한 위치에 노드를 삽입하는 구조
    * List의 가장 앞쪽에 최고 우선순위가 위치하게 됨
  * 배열 대비 장점
    * 삽입/삭제 연산 이후 원소의 재배치가 필요 없음
    * 메모리의 효율적인 사용이 가능함