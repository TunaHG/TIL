# Brute Force

모든 경우의 수를 다 해보는 알고리즘

예를 들어, 4자리 비밀번호를 알아낼 경우 0000부터 9999까지 10000가지 경우의 수를 전부 해보는 것.

모든 문제를 해결할 수 있는 방법이 아니고, 경우의 수가 많지 않을때 사용할 수 있는 방법
경우의 수를 다 해보는데 걸리는 시간이 문제의 시간 제한을 넘지 않아야 한다.

문제를 푸는 3가지 단계

1. 문제의 가능한 경우의 수를 계산한다.
   직접 계산을 통해서 구한다. 대부분 손으로 계산해볼 수 있다.
2. 가능한 모든 방법을 만든다.
   하나도 빠짐 없이 만들어야 한다.
   대표적으로 그냥 다 해보는 방법, for문, 순열, 재귀호출, 비트마스크 등을 사용한다.
3. 각각의 방법을 이용해 답을 구한다.
   이 단계는 보통 어렵지 않다. 문제에 나와있는 대로 답을 계산한다.

브루트 포스 문제의 시간 복잡도는 대부분 O(경우의수 * 방법 1개를 시도해보는데 걸리는 시간 복잡도)가 걸린다.

## 경우의 수

* N명의 사람이 한 줄로 서는 경우의 수 : $ N!$
* N명의 사람 중에서 대표 두 명을 뽑는 경우의 수 : $ _{N}\mathrm{C}_{2}$ 
* N명의 사람 중에서 대표 세 명을 뽑는 경우의 수 : $ _{N}\mathrm{C}_{3}$
* N명의 사람 중에서 반장 1명과 부반장 1명을 뽑는 경우의 수 : $ N \times (N - 1) $
* N명의 사람이 있을 때, 각 사람이 영화를 볼지, 보지 않을지 결정한다. 가능한 조합의 수 :  $ 2 ^N$

## 그냥 다 해보기

### 일곱 난쟁이

> https://www.acmicpc.net/problem/2309

아홉 명중 일곱 명을 찾는 문제
일곱 난쟁이의 키의 합은 100이다.

가능한 경우를 출력하고 종료하라는 문구가 있으므로 return을 넣어줘야한다.

### 사탕 게임

> https://www.acmicpc.net/problem/3085

N X N 크기의 테이블에 사탕이 있음. 인접한 두 칸을 고르고 사탕을 교환한다.
같은 색으로 이루어져 있는 가장 긴 연속부분 행 또는 열을 고르는 문제

각 칸에서 오른쪽, 아래랑만 교환한다. 그렇게 되면 오른쪽칸은 이미 왼쪽과 교환한 이후므로 또 오른쪽, 아래랑만 교환하면 된다.

인접한 두 칸을 고르고 사탕을 교환하는 경우는 $N^2 \times 2$가지 경우가 가능하고, 가장 긴 연속 부분 행 또는 열을 고르는 방법은 $O(N^2)$이 걸린다.
그러므로 총 시간복잡도는 $O(N^4)$이 된다.

가장 긴 연속 부분 행 또는 열을 고르는 방법은 $O(3N)$으로 줄일 수 있다.

### 날짜 계산

> https://www.acmicpc.net/problem/1476

가능한 E의 개수는 15, S의 개수는 28, M의 개수는 19
전체 경우의 수는 $ 15 \times 28 \times 19 = 7980$ 적은 수이므로 브루트포스로 진행해도 된다.

아니면 나머지 연산을 활용하여 풀 수 있다.

중국인의 나머지 정리로도 풀 수 있다.

### 리모컨

> https://www.acmicpc.net/problem/1107

+, -를 누르다가 숫자버튼을 누르는 순간 그 전까지 입력한 것이 의미가 없어진다.
-를 누른 이후 +를 누르는 경우 역시 의미가 없다. 중복된 채널이 나오기 때문에 최소값이랑은 거리가 멀다.

따라서, 숫자버튼을 먼저 누르고 이후 +나 -중 하나만 연속해서 눌러야 한다.

주의해야 할점은 채널은 무한대인데 이동하려고 하는 채널이 500000인 것이다.
500000보다 높은 수에서 -를 눌러서 내려오는 경우의 수도 생각해야 하기 때문에 여유롭게 1000000까지 탐색한다.

1. 이동할 채널 C를 정한다.
2. C에 포함되어 있는 숫자 중 고장난 버튼이 있는지 확인한다.
   수를 문자열로 바꾼다음 한 글자씩 검사하거나 수를 10으로 계속 나누면서 하나씩 검사하는 방법이 있다.
3. 고장난 버튼이 포함되어 있지 않다면 C-N의 절대값을 계산해서 +나 -버튼을 몇 번 눌러야 하는지를 계산한다.

### 테트로미노

> https://www.acmicpc.net/problem/14500

테트로미노가 총 19가지가 있고, 하나의 테트로미노당 놓을 수 있는 방법의 개수는 약 $O(MN)$가지 이다. 

## 건너뛰며 해보기

### 카잉 달력

> https://www.acmicpc.net/problem/6064

주어지는 M이나 N만큼 건너뛰어가면서 계산한다.

역시 날짜계산처럼 나머지연산으로 진행할 수 있다.

### 수 이어 쓰기 1

> https://www.acmicpc.net/problem/1748

수의 자리수별로 나누어서 문제를 해결할 수 있다.

1부터 N까지 빠짐없이 수가 존재하기때문에 사용할 수 있는 방법.

## N과 M

### N과 M (1)

> https:///www.acmicpc.net/problem/15649

중복없이를 위해 어떤 수를 사용했고 어떤 수를 사용했는지를 기록할 배열이 필요하다. visited[]와 같은 배열

### N과 M (2)

> https://www.acmicpc.net/problem/15650

1번과 동일하지만, 결과가 오름차순이어야 한다는 조건이 추가된 문제

재귀를 사용하면 start와 같은 매개변수가 하나 추가됨. 오름차순을 위한 매개변수
이 경우 시간복잡도는 $O(N!)$이 된다.

다른방식으로, M개의 수에 어떤 수가 들어갈지 결정하는 방식이 있다.
M이 3일때, (1, 4, 7)이면 해당 숫자로 나올 수 있는 오름차순은 1, 4, 7뿐이라는 것을 이용한다.
이 경우 각 수를 선택하거나, 선택하지 않거나의 경우의 수이므로 $O(2^N)$의 시간복잡도를 가지며 재귀함수로 구현하는 경우 selected라는 지금까지 선택한 수의 개수라는 매개변수를 활용한다.

결과를 사전순으로 출력해야 하기 때문에 1이 포함되는 것부터 처리해줘야 한다.
그렇기에 선택하거나 선택하지 않거나의 두 경우의 수 중 선택하는 경우를 먼저 구현해야 한다.

### N과 M (3)

> https://www.acmicpc.net/problem/15651

1번과 동일하지만, 중복이 가능한 문제

### N과 M (4)

> https://www.acmicpc.net/problem/15652

중복 선택이 가능하나 비내림차순(오름차순 + 같은수)의 조건이 추가된 문제

### N과 M (5)

> https://www.acmicpc.net/problem/15654

5~8까지는 1~4까지와 동일하게 풀면된다.
N개의 수를 주어주기 때문에 해당 수에 대한 배열을 가지고 진행하면 된다.1

###  N과 M (9)

> https://www.acmicpc.net/problem/15663

5번 문제풀이 + 중복제거로 진행한다. 

## 순열

임의의 수열을 다른 순서로 섞는 연산.
크기가 N인 수열의 서로 다른 순열은 총 N!개가 있다.

다음 순열. 사전순으로 다음에 오는 순열과 이전에 오는 순열을 찾는 방법이다.

첫 순열은 오름차순이 된다면 마지막 순열은 내림차순이 된다.
7, 2, 3, 6, 5, 4, 1은 7, 2, 3으로 시작하는 마지막 순열이 된다. (6, 5, 4, 1)이 내림차순이기 때문에.
또한 7, 2로 시작하는 첫 순열이 된다. 그렇다고 다음순열이 7, 2, 4가 되는 것은 아니다. 뒤에 오는 수들 중에서 3보다 큰 수들 중 가장 작은 수가 된다. 현재는 6, 5, 4중에 4이기 때문에 4가 오는 것이 맞다.
7, 2, 4, 6, 5, 3, 1은 7, 2, 4로 시작하는 마지막 순열이므로 6, 5, 3, 1을 뒤집으면 오름차순이 되므로 7, 2, 4로 시작하는 첫 순열이 된다.

다음순열을 찾는 시간복잡도는 O(N)이다.

모든 순열을 찾는 시간복잡도는 O()

### 다음 순열

> https://www.acmicpc.net/problem/10972

### 이전 순열

> https://www.acmicpc.net/problem/10973

### 모든 순열

> https://www.acmicpc.net/problem/10974

### 차이를 최대로

> https://www.acmicpc.net/problem/10819

제한이 8밖에 안된다는 점을 이용하여 문제 해결

정렬은 필수. 다음 순열을 활용해서 모든 순열을 구하려면 첫 순열은 무조건 오름차순으로 정렬되어 있어야 하기 때문.

### 외판원 순회 2

> https://www.acmicpc.net/problem/10971

TSP, Traveling Salesman Problem

### 로또

> https://www.acmicpc.net/problem/6603

