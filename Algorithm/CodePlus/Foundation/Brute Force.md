# Brute Force

모든 경우의 수를 다 해보는 알고리즘

예를 들어, 4자리 비밀번호를 알아낼 경우 0000부터 9999까지 10000가지 경우의 수를 전부 해보는 것.

모든 문제를 해결할 수 있는 방법이 아니고, 경우의 수가 많지 않을때 사용할 수 있는 방법
경우의 수를 다 해보는데 걸리는 시간이 문제의 시간 제한을 넘지 않아야 한다.

문제를 푸는 3가지 단계

1. 문제의 가능한 경우의 수를 계산한다.
   직접 계산을 통해서 구한다. 대부분 손으로 계산해볼 수 있다.
2. 가능한 모든 방법을 만든다.
   하나도 빠짐 없이 만들어야 한다.
   대표적으로 그냥 다 해보는 방법, for문, 순열, 재귀호출, 비트마스크 등을 사용한다.
3. 각각의 방법을 이용해 답을 구한다.
   이 단계는 보통 어렵지 않다. 문제에 나와있는 대로 답을 계산한다.

브루트 포스 문제의 시간 복잡도는 대부분 O(경우의수 * 방법 1개를 시도해보는데 걸리는 시간 복잡도)가 걸린다.

## 경우의 수

* N명의 사람이 한 줄로 서는 경우의 수 : $ N!$
* N명의 사람 중에서 대표 두 명을 뽑는 경우의 수 : $ _{N}\mathrm{C}_{2}$ 
* N명의 사람 중에서 대표 세 명을 뽑는 경우의 수 : $ _{N}\mathrm{C}_{3}$
* N명의 사람 중에서 반장 1명과 부반장 1명을 뽑는 경우의 수 : $ N \times (N - 1) $
* N명의 사람이 있을 때, 각 사람이 영화를 볼지, 보지 않을지 결정한다. 가능한 조합의 수 :  $ 2 ^N$

## 그냥 다 해보기

### 일곱 난쟁이

> https://www.acmicpc.net/problem/2309

아홉 명중 일곱 명을 찾는 문제
일곱 난쟁이의 키의 합은 100이다.

가능한 경우를 출력하고 종료하라는 문구가 있으므로 return을 넣어줘야한다.

### 사탕 게임

> https://www.acmicpc.net/problem/3085

N X N 크기의 테이블에 사탕이 있음. 인접한 두 칸을 고르고 사탕을 교환한다.
같은 색으로 이루어져 있는 가장 긴 연속부분 행 또는 열을 고르는 문제

각 칸에서 오른쪽, 아래랑만 교환한다. 그렇게 되면 오른쪽칸은 이미 왼쪽과 교환한 이후므로 또 오른쪽, 아래랑만 교환하면 된다.

인접한 두 칸을 고르고 사탕을 교환하는 경우는 $N^2 \times 2$가지 경우가 가능하고, 가장 긴 연속 부분 행 또는 열을 고르는 방법은 $O(N^2)$이 걸린다.
그러므로 총 시간복잡도는 $O(N^4)$이 된다.

가장 긴 연속 부분 행 또는 열을 고르는 방법은 $O(3N)$으로 줄일 수 있다.

### 날짜 계산

> https://www.acmicpc.net/problem/1476

가능한 E의 개수는 15, S의 개수는 28, M의 개수는 19
전체 경우의 수는 $ 15 \times 28 \times 19 = 7980$ 적은 수이므로 브루트포스로 진행해도 된다.

아니면 나머지 연산을 활용하여 풀 수 있다.

중국인의 나머지 정리로도 풀 수 있다.

### 리모컨

> https://www.acmicpc.net/problem/1107

+, -를 누르다가 숫자버튼을 누르는 순간 그 전까지 입력한 것이 의미가 없어진다.
-를 누른 이후 +를 누르는 경우 역시 의미가 없다. 중복된 채널이 나오기 때문에 최소값이랑은 거리가 멀다.

따라서, 숫자버튼을 먼저 누르고 이후 +나 -중 하나만 연속해서 눌러야 한다.

주의해야 할점은 채널은 무한대인데 이동하려고 하는 채널이 500000인 것이다.
500000보다 높은 수에서 -를 눌러서 내려오는 경우의 수도 생각해야 하기 때문에 여유롭게 1000000까지 탐색한다.

1. 이동할 채널 C를 정한다.
2. C에 포함되어 있는 숫자 중 고장난 버튼이 있는지 확인한다.
   수를 문자열로 바꾼다음 한 글자씩 검사하거나 수를 10으로 계속 나누면서 하나씩 검사하는 방법이 있다.
3. 고장난 버튼이 포함되어 있지 않다면 C-N의 절대값을 계산해서 +나 -버튼을 몇 번 눌러야 하는지를 계산한다.

### 테트로미노

> https://www.acmicpc.net/problem/14500

테트로미노가 총 19가지가 있고, 하나의 테트로미노당 놓을 수 있는 방법의 개수는 약 $O(MN)$가지 이다. 

## 건너뛰며 해보기

### 카잉 달력

> https://www.acmicpc.net/problem/6064

주어지는 M이나 N만큼 건너뛰어가면서 계산한다.

역시 날짜계산처럼 나머지연산으로 진행할 수 있다.

### 수 이어 쓰기 1

> https://www.acmicpc.net/problem/1748

수의 자리수별로 나누어서 문제를 해결할 수 있다.

1부터 N까지 빠짐없이 수가 존재하기때문에 사용할 수 있는 방법.

## N과 M

### N과 M (1)

> https:///www.acmicpc.net/problem/15649

중복없이를 위해 어떤 수를 사용했고 어떤 수를 사용했는지를 기록할 배열이 필요하다. visited[]와 같은 배열

### N과 M (2)

> https://www.acmicpc.net/problem/15650

1번과 동일하지만, 결과가 오름차순이어야 한다는 조건이 추가된 문제

재귀를 사용하면 start와 같은 매개변수가 하나 추가됨. 오름차순을 위한 매개변수
이 경우 시간복잡도는 $O(N!)$이 된다.

다른방식으로, M개의 수에 어떤 수가 들어갈지 결정하는 방식이 있다.
M이 3일때, (1, 4, 7)이면 해당 숫자로 나올 수 있는 오름차순은 1, 4, 7뿐이라는 것을 이용한다.
이 경우 각 수를 선택하거나, 선택하지 않거나의 경우의 수이므로 $O(2^N)$의 시간복잡도를 가지며 재귀함수로 구현하는 경우 selected라는 지금까지 선택한 수의 개수라는 매개변수를 활용한다.

결과를 사전순으로 출력해야 하기 때문에 1이 포함되는 것부터 처리해줘야 한다.
그렇기에 선택하거나 선택하지 않거나의 두 경우의 수 중 선택하는 경우를 먼저 구현해야 한다.

### N과 M (3)

> https://www.acmicpc.net/problem/15651

1번과 동일하지만, 중복이 가능한 문제

### N과 M (4)

> https://www.acmicpc.net/problem/15652

중복 선택이 가능하나 비내림차순(오름차순 + 같은수)의 조건이 추가된 문제

### N과 M (5)

> https://www.acmicpc.net/problem/15654

5~8까지는 1~4까지와 동일하게 풀면된다.
N개의 수를 주어주기 때문에 해당 수에 대한 배열을 가지고 진행하면 된다.1

###  N과 M (9)

> https://www.acmicpc.net/problem/15663

5번 문제풀이 + 중복제거로 진행한다. 

## 순열

임의의 수열을 다른 순서로 섞는 연산.
크기가 N인 수열의 서로 다른 순열은 총 N!개가 있다.

다음 순열. 사전순으로 다음에 오는 순열과 이전에 오는 순열을 찾는 방법이다.

첫 순열은 오름차순이 된다면 마지막 순열은 내림차순이 된다.
7, 2, 3, 6, 5, 4, 1은 7, 2, 3으로 시작하는 마지막 순열이 된다. (6, 5, 4, 1)이 내림차순이기 때문에.
또한 7, 2로 시작하는 첫 순열이 된다. 그렇다고 다음순열이 7, 2, 4가 되는 것은 아니다. 뒤에 오는 수들 중에서 3보다 큰 수들 중 가장 작은 수가 된다. 현재는 6, 5, 4중에 4이기 때문에 4가 오는 것이 맞다.
7, 2, 4, 6, 5, 3, 1은 7, 2, 4로 시작하는 마지막 순열이므로 6, 5, 3, 1을 뒤집으면 오름차순이 되므로 7, 2, 4로 시작하는 첫 순열이 된다.

다음순열을 찾는 시간복잡도는 O(N)이다.

모든 순열을 찾는 시간복잡도는 O()

### 다음 순열

> https://www.acmicpc.net/problem/10972

### 이전 순열

> https://www.acmicpc.net/problem/10973

### 모든 순열

> https://www.acmicpc.net/problem/10974

### 차이를 최대로

> https://www.acmicpc.net/problem/10819

제한이 8밖에 안된다는 점을 이용하여 문제 해결

정렬은 필수. 다음 순열을 활용해서 모든 순열을 구하려면 첫 순열은 무조건 오름차순으로 정렬되어 있어야 하기 때문.

### 외판원 순회 2

> https://www.acmicpc.net/problem/10971

TSP, Traveling Salesman Problem

### 로또

> https://www.acmicpc.net/problem/6603

##  재귀

재귀함수를 이용해서 문제를 해결하는 방법

### 1, 2, 3 더하기

> https://www.acmicpc.net/problem/9095

count개로 합 sum을 만드는 경우의 수를 구하는 재귀함수 go(count, sum, goal)을 이용

재귀를 활용한 Brute force의 절차

1. 불가능한 경우
   아무리 재귀함수의 호출을 반복해도 정답을 구할 수 없는 경우 혹은 문제의 조건을 위배하는 경우 (sum > goal)
2. 정답을 찾은 경우
   문제의 정답을 찾은 경우 혹은 더 이상 함수 호출을 이어나갈 필요가 없는 경우 (sum == goal)
3. 다음 경우를 호출

이후 count가 없어도 문제가 잘 동작하는 것 같으니 count를 제거한 재귀함수 생성 가능

### 암호 만들기

> https://www.acmicpc.net/problem/1759

암호에서 증가하는 순서로 배열되어야 하는 조건
알파뱃을 정렬해둔 다음에 암호에 포함되는지 안되는지를 선택하면 된다.

만들어야 하는 암호의 길이(n), 사용할 수 있는 알파뱃 배열(alpha), 현재까지 만든 암호(password), 사용할지 말지 결정해야 하는 알파뱃의 인덱스(i)
위 4개를 매개변수로 가지는 재귀함수를 만든다.

1. 정답을 찾은 경우
   password의 길이 == n, 모음과 자음의 개수인 조건은 나중에 처리
   암호를 전부 만든다음에 모음과 자음 개수 조건을 만족하는 암호만 선택하는 방법을 사용
2. 불가능한 경우
   i >= alpha의 크기
3. 다음 경우
   1. i번째를 사용하는 경우 go(n, alpha, password + alpha[i], i + 1)
   2. i번째를 사용하지 않는 경우 go(n, alpha, password, i + 1)

코드 구현에서 정답을 찾은 경우가 불가능한 경우보다 먼저와야함. 마지막 알파뱃을 포함한 이후에 정답이지만 다음 알파뱃이 없는 경우가 존재하기 때문

### 퇴사

> https://www.acmicpc.net/problem/14501

각각의 날짜마다 상담을 한다 안한다로 선택한다.

go(day, sum) day는 해당 날짜의 상담을 할지 말지 결정하는 매개변수, 지금까지 얻은 수익을 sum

1. 정답을 찾은 경우
   day == n + 1, 최대값을 구하는 과정이 필요
2. 불가능한  경우
   day > n + 1
3. 다음 경우 호출
   1. day에 상담을 하는 경우
      go(day + T[day], sum + P[day])
   2. day에 상담을 하지 않는 경우
      go(day + 1, sum)

## 백트래킹

재귀 함수를 이용해 브루트 포스를 하다보면, 더 이상 함수 호출이 의미 없는 경우가 있다.
이런 경우를 제외하고 브루트포스를 진행하면 백트래킹이라고 한다.

### 스타트와 링크

> https://www.acmicpc.net/problem/14889

각사람이 어떤 팀에 들어간다고 결정한다면 모든 방법의 수는 $ 2^N$개

go(index, first, second)
index번째 사람을 어떤 팀에 넣을지 결정, first, second에 1번팀 2번팀에 속한 사람이 들어있음.

1. 정답을 찾은 경우
   index == n

2. 다음 경우 호출

   1. 1번팀 go(index, first, second)
   2. 2번팀 go(index, first, second)

   두 경우 모두 first, second에 index를 넣고, 호출 후에 빼는 과정이 필요함

지금까지는 사람을 다 넣어보고 n/2인지 아닌지를 판별한다.
하지만 한 팀이 n/2명을 넘어가면 더이상 한팀에 인원이 추가될 수 없기 때문에 이 부분을 불가능한 경우로 제외할 수 있다.

### 부등호

> https://www.acmicpc.net/problme/2529

조건으로 각 정수에 올 수 있는 수는 0~9중 하나이다.

부등호에 대한 조건은 전체 수를 전부 넣은 이후에 판별한다.

go(index, num)

개선된 방법
수를 전부 선택하고 부등호를 판별하는 것보다 수를 선택하는것과 함께 부등호를 판별하는 것이 좋다.

### 맞춰봐

> https://www.acmicpc.net/problem/1248

각각의 자리에 올 수 있는 수는 21개가 있다. 자리가 10개이므로 올 수 있는 수의 조합은 $21^{10}$이 된다. 수가 너무 커서 시간초과가 발생할 것이다.

S배열에서 i와 j가 같을 경우의 값을 살펴보면 i번째가 양수인지 음수인지 0인지 알 수 있다.
하지만 이 방법도 $10 ^{10}$이라 아직 너무 크다.

i번째 수를 알아냈으면 해당 수까지의 S배열을 검사할 수 있다.

백트래킹은 이론상으로는 시간이 초과되나, 중간에 그만두는 경우가 많아져서 해결되는 경우가 많다.

## 비트마스크

Bit 연산을 사용해서 부분 집합을 표현하는 방법

Bit 연산 & (and), | (or), ~ (not), ^ (xor)

![image-20210108132143933](C:\TIL\Algorithm\CodePlus\Foundation\images\Brute Force\image-20210108132143933.png)