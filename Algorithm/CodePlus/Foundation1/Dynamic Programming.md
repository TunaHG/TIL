# Dynamic Programming

## Dynamic Programming 개념

> 동적계획법
>
> 문제의 크기가 큰 문제를 작은 문제로 나눠서 푸는 알고리즘, https://en.wikipedia.org/wiki/Dynamic_programming#History

이렇게 문제의 크기를 나누는 알고리즘은 DP와 분할정복(Divide & Conquer)가 있다.
DP는 큰 문제들을 작은 문제로 나누었을 때 중복이 가능할 경우, 분할정복은 중복이 불가능할 경우이다.

DP 문제를 풀기위해서는 두 가지 속성을 만족해야 한다.
첫 번째는 Overlapping Subproblem 속성으로 겹치는 부분문제를 의미한다. 부분의 작은 문제들이 중복되면 DP로 문제를 해결한다.
두 번째는 Optimal Substructure 속성으로 최적 부분구조를 의미한다.

* **Overlapping Subproblem**
  피보나치의 수를 예시로 들어 설명한다. 피보나치의 수는 다음과 같다.
  0번째 수는 0, 1번째 수는 1로 고정되어 있고, 2번째 수부터는 이전 두 수의 합으로 이루어져 있다.
  0, 1, 1, 2, 3, 5, 8, 13, 21, ...

  $ F_{n} = F_{n-1} + F_{n-2} (n \geq 2) $

  $ F_{n} $이 여기서 큰 문제가 되고, $ F_{n-1} $과 $ F_{n-2} $가 작은 문제가 된다.
  결국 N번째 피보나치 수를 구하는 문제가 큰 문제가 되며, N-1번째와 N-2번째 피보나치 수를 구하 는 문제가 작은 문제가 된다.

  크다와 작다는 상대적이기 때문에, 이를 더 깊게 들어가면
  N-1번째 피보나치 수를 구하는 문제를 큰 문제라고 생각하면, N-2번째 피보나치수와 N-3번째 피보나치 수를 구하는 문제가 작은 문제가 된다.

  이렇게 깊게 들어가면, N번째 피보나치수와 N-1번째 피보나치 수를 구할 때 N-2번째 피보나치 수가 중복해서 들어간다는 것을 확인할 수 있다.
  이렇게 **중복되는 값이 존재할때**를 Overlapping Subproblem이라고 한다.

  **큰 문제와 작은 문제를 같은 방법으로 풀 수 있고, 문제를 작은 문제로 쪼갤 수 있다.**

* **Optimal Substructure**
  **문제의 정답을 작은 문제의 정답에서 구할 수 있다.**
  
  예를 들어, 서울에서 부산을 가는 가장 빠른 길이 대전과 대구를 순서대로 거쳐야 한다면 대전에서 부산을 가는 가장 빠른 길은 대구를 거쳐야 한다.
  만약 대전에서 부산을 가는 가장 빠른 길이 울산을 거치는 길이라면, 서울에서 부산을 가는 가장 빠른 길이 대전과 대구를 거치는 길이 아니라 대전과 울산을 거치는 길이 될 것이므로 기존의 대전과 대구를 거치는 길이라는 가정은 오류가 된다.

  이 속성을 만족한다면, 문제의 크기에 상관없이 어떤 한 문제의 정답은 일정하다.
  10번째 피보나치 수를 구할 때의 4번째 피보나치 수와 9번째 피보나치 수를 구할 때의 4번째 피보나치 수가 같다.
  결국 4번째 피보나치 수를 필요로 할 때 4번째 피보나치 수는 항상 같다.

  **DP에서 각 문제는 한 번만 풀어야 한다. 또한 같은 문제는 구할 때마다 정답이 같다.**
  그렇기에 정답을 구했으면 정답을 어딘가에 메모해 놓는다. 코드의 구현에서는 배열에 저장하는 것으로 진행할 수 있다.
  이러한 메모의 과정을 **Memoization**이라고 한다.

  이 방법을 활용하면 어떻게 개선되는지 확인한다.

  * **Memoization을 활용하지 않은 문제해결**
  
    ```c
    int fibonacci(int n) {
        if (n <= 1) {
            return n;
        } else {
            return fibonacci(n-1) + fibonacci(n-2);
        }
    }
    ```
  
    이와 같이 문제를 해결하면 해당 재귀함수가 어떻게 호출되는지 그림으로 다음과 같이 나타낼 수 있다.
    ![image-20201228104814744](C:\TIL\Algorithm\CodePlus\Foundation1\images\image-20201228104814744.png)
    동일한 함수가 여러번 호출되는 것을 확인할 수 있다.
  
  * **Memoization을 활용한 문제해결**

    ```c
    int memo[100];
    int fibonacci(int n) {
        if(n <= 1) {
            return n;
        } else {
            if(memo[n] > 0) {
                return memo[n];
            }
            memo[n] = fibonacci(n-1) + fibonacci(n-2);
            return memo[n];
        }
    }
    ```

    이와 같이 문제를 해결하면 해당 재귀함수가 어떻게 호출되는지 그림으로 다음과 같이 나타낼 수 있다.
    ![image-20201228105047617](C:\TIL\Algorithm\CodePlus\Foundation1\images\image-20201228105047617.png)
    호출되는 함수의 수가 현저히 줄어드는 것을 확인할 수 있다.
    **시간 복잡도**를 확인해보면 모든 문제를 한번씩 풀기 때문에 문제의 개수 * 문제 1개를 푸는 시간으로 계산한다.
    피보나치 수의 경우 N번째를 구하려면 총 N개의 문제를 구해야 하며
    문제 1개를 푸는 시간은 함수의 시간 복잡도와 같은 의미를 가지므로 + 하나만 있는 함수 상 O(1)이 된다.
    그러므로 총 **O(N)**이 된다.

**DP의 구현방식**에는 **Top-down(재귀)**과 **Botton-up(반복)**의 두 가지 방법이 있다.
**두 방법의 시간 차이는 알 수 없다.** 재귀에서는 스택을 활용하기 때문에 스택오버플로우가 발생할 수도 있다.
그래서 반복문을 활용하는게 더 빠르고 좋을 것 같지만, Bottom-up 방식은 정말 모든 방식을 풀기 때문에 경우에 따라 시간이 더 오래걸릴 수 있기 때문에 알 수 없다.
C++, Java의 경우 스택오버플로우가 거의 발생하지 않고, 발생할 경우는 구현을 잘못한 경우가 많기 때문에 신경쓰지 않아도 된다.

* **Bottom-up**
  문제를 크기가 작은 문제부터 차례대로 문제의 크기를 조금씩 크게 만들면서 푼다.
  **반복문**을 사용하여 해결한다.

  ```c
  int d[100];
  int fibonacci(int n) {
      d[0] = 0;
      d[1] = 1;
      for (int i=2; i<=n; i++) {
          d[i] = d[i-1] + d[i-2];
      }
      return d[n];
  }
  ```

* **Top-down**
  기존에 알아본 것 처럼 **재귀함수**를 사용한 방법

## 문제 풀이 전략

문제에서 구하려고 하는 답을 문장으로 나타내는 **점화식을 정의**하는 경우가 많다.

점화식의 정의가 문제에서 구해야 하는 값을 그대로 나타내는 경우인 문제가 존재하고,
조금 더 나아가서 **점화식의 정의를 변경**해야 하는 것을 해결한다.

## 문제 풀이

### 1로 만들기

> https://www.acmicpc.net/problem/1463

정수 X에 사용할 수 있는 연산은 다음의 세가지

1. X가 3으로 나누어 떨어지면, 3으로 나눈다.
2. X가 2로 나누어 떨어지면, 2로 나눈다.
3. 1을 뺀다

어떤 정수 N에 위와 같은 연산을 선택해서 1을 만드려고 한다. 연산을 사용하는 횟수의 최소값을 구하는 문제

3으로 나누는 것이 수를 가장 빠르게 작게 만들수 있으므로 3으로 나누는 것, 2로 나누는 것, 1을 빼는 것 순서의 우선순위로 N을 1로 만들어볼 수 있다.
하지만 이 방법에 대한 반례는 10이다. 생각한 방법대로라면 10 > 5 > 4 > 2 > 1 의 과정으로 1이 되나, 실제방법은 10 > 9 > 3 > 1이 존재한다.

이 문제에 대한 점화식을 정의한다.
$ D[N] = N을 1로 만드는 최소 연산 횟수$ 
문제의 난이도가 낮으면 문제를 작게 나눌수 있는 방법이 주어진다.
1번 연산을 사용하는 경우 N을 1로만드는 연산 횟수는 N/3을 1로 만드는 최소 연산횟수 + 1번이다.
마찬가지로 2번 연산을 사용하는 경우 N/2를 1로 만드는 최소 연산횟수 + 1번이다.

정리하면, $ D[N] = min(D[N/3], D[N/2], D[N-1]) + 1 $이 된다.

* **Top-down 방식을 활용한 풀이**

  ```c
  int go(int n) {
      if(n == 1) return 0;
      if(d[n] > 0) retrun d[n]; // Memoization
      d[n] = go(n-1) + 1; // 3번 경우
      if(n%2 == 0){ // 2번 경우
          int temp = go(n/2) + 1;
          if(d[n] > temp) d[n] = temp;
      }
      if(n%3 == 0){ // 1번 경우
          int temp = go(n/3) + 1;
          if(d[n] > temp) d[n] = temp;
      }
      return d[n];
  }
  ```

  해당 풀이과정의 시간복잡도를 살펴본다. 
  함수의 호출횟수를 의미하는 문제의 개수와 함수의 시간복잡도를 의미하는 문제 1개 푸는데 필요한 시간복잡도를 곱한다.
  문제의 개수는 N개이며, 문제 1개 푸는데 필요한 시간복잡도는 O(1)이므로 시간복잡도는 O(N)이 된다.

문제에서 선택할수 있는 연산의 순서는 N/3 > N/2 > N-1이였는데 왜 코드구현은 반대로 했는가?
최소값을 쉽게 구하기 위해서. N/3과 N/2는 각각 나누어떨어져야하는데 N-1은 그 이외의 경우에 항상 진행하기 때문에 N-1을 먼저 진행하고 이후의 과정에서 비교를 통해 최소값을 탐색한다.

* Bottom-up 방식을 활용한 풀이

  ```c
  d[1] = 0;
  for (int i=2; i<=n; i++) {
      d[i] = d[i-1] + 1;
      if(i%2 == 0 && d[i] > d[i/2] + 1) {
          d[i] = d[i/2] + 1;
      }
      if(i%3 == 0 && d[i] > d[i/3] + 1) {
          d[i] = d[i/3] + 1;
      }
  }
  ```

### 2 X n 타일링

> https://www.acmicpc.net/problem/11726

2 X n 직사각형을 1X2, 2X1 타일로 채우는 방법의 수
D[n] = 2 X n 직사각형을 채우는 방법의 수
마지막 단계를 진행하지 않았을 때 문제가 어떻게 변하는지 파악하여 문제를 해결한다.

2X1타일이 하나 오는 경우 2 X (n-1) (D[n-1])의 타일을 채우고 1번을 더하면 완성된다.
1X2타일을 사용하는 경우에는 항상 위아래로 두개가 함께 와야한다. 그러므로 2 X (n-2) (D[n-2])의 타일을 채우고 2번을 더하면 완성된다.
정리하면, $D[n] = D[n-1] + D[n-2]$가 된다. 이를 그림으로 표현하면 다음과 같다.
![image-20201228124149447](C:\TIL\Algorithm\CodePlus\Foundation1\images\image-20201228124149447.png)

Q. 1X2 타일을 사용하는 경우는 2개오는데 2X1 타일을 사용하는 경우는 왜 2개가 오면 안되나요?
A. 2X1 타일을 사용하는 경우는 마지막 단계 1번을 진행하지 않았을 경우에 1개만 해당되기 때문.

### 2 X n 타일링 2

> https://www.acmicpc.net/problem/11727

2 X n 직사각형을 1X2, 2X1, 2X2 타일로 채우는 방법의 수
이전문제와 동일하게 진행하며 2X2타일로 채우는 방법의 수는 1X2가 두개 들어가는 방법의 수와 동일하다.
하지만 1X2가 두개 들어가는 방법과 동일하지는 않으므로 D[n-2]를 한번 더 더해주면 된다.
결국, $ D[n] = D[n-1] + D[n-2] + D[n-2] $가 된다. 그림으로 표현하면 다음과 같다.

![image-20201228124531540](C:\TIL\Algorithm\CodePlus\Foundation1\images\image-20201228124531540.png)

### 1, 2, 3 더하기

> https://www.acmicpc.net/problem/9095

정수 n을 1, 2, 3의 합으로 나타내는 방법의 수를 구하는 문제

DP문제 답게 D[n]을 구하기 위해 D[n-1]을 살펴본다. 마지막 단계에는 +1, +2, +3이 올 수 있다.
n-1의 합에 1을 더하면 n이되고, n-2의 합에 2를 더하면 n이되고, n-3의 합에 3을 더하면 n이된다.
결국, $ D[n] = D[n-1] + D[n-2] + D[n-3] $이 된다.

이를 표현하기 전에, $D[0]$은 어떻게 나타내야 할지 고민해봐야한다.
+1, +2, +3 아무것도 사용하지 않고 표현할 수 있으므로 1로 나타낼수 있다.

풀이과정을 그림으로 표현해보면 다음과 같다.
![image-20201228125131703](C:\TIL\Algorithm\CodePlus\Foundation1\images\image-20201228125131703.png)

**지금까지 풀어본 3문제 모두 시간복잡도는 O(N)이며, 점화식을 정의하면 문제가 해결되는 경우이다.**

### 카드 구매하기

> https://www.acmicpc.net/problem/11052

N개의 카드를 구매하는데 카드팩은 총 N가지 종류가 있다.
i번째 카드팩은 i개의 카드를 담고 있고, 가격은 P[i]원이다.
카드 N개를 구매하는 비용의 최대값을 구하는 문제

마지막 카드팩에 카드가 몇개가 들었을지 생각해보면 개수를 알 수 없다.
보통 알고리즘에서는 알 수 없다면 생각을 잘못한것이지만 DP에서는 알 수 없다가 나와도 괜찮다. 모든 경우의 수를 다 해보면 되기 때문이다.
마지막 카드팩에 i개의 카드가 들어있었다면 그 전까지 구매한 카드팩에는 N-i개의 카드가 들어있었을 것이다.
이를 기반으로 점화식을 만들어본다.

$ D[N] = max(P[i] + D[N - i]) $가 되며 i의 범위는 1부터 N까지가 된다.
점화식만으로 시간복잡도를 계산해 볼 수 있다. N개 X O(N)이므로 O(N제곱)이다.

### 카드 구매하기 2

> https://www.acmicpc.net/problem/16194

카드 구매하기 1과 흡사하지만 최대값이 아닌 최소값을 구하는 문제다.
max만 min으로 변경하면 될 것 같지만 그렇지 않다.

DP 배열에 항상 0이 들어가나, 카드를 구매하는 비용은 0보다 크기 때문에 min의 결과는 항상 0이다.
그래서 배열의 초기값을 잘 설정해야 한다.

첫번째 방법은 1000 * 10000으로 초기화하는 방법이다.
문제에 주어진 조건으로 카드의 개수는 1000보다 작고 카드팩의 가격은 10000보다 작기때문에 최대값으로 초기화하는 방법이다.

두번째 방법은 -1로 초기화하는 방법이다.
-1로 전부 초기화한 이후 -1이라면 아직 정답을 구하지 않았다는 의미이다.

경우의 수를 구할때는 0이라는 경우의 수가 존재할 수 있기 때문에 최대값이 아닌 -1로 초기화하는 것을 추천한다.

### 1, 2, 3 더하기 5

> https://www.acmicpc.net/problem/15990

위의 문제에서 같은 수를 두 번 인상 연속해서 사용하면 안된다는 조건이 추가된 문제이다.

연속과 같은 경우에는 두개를 묶어주면 된다.
두 번 이상 연속하면 안된다는 경우에는 

$D[i][j]$를 활용하여 i를 1, 2, 3의 합으로 나타내는 방법의수, j를 마지막에 사용한 수로 생각한다.
$D[i][1] = D[i-1][2] + D[i-1][3]$과 같은 방식을 활용한다.

1,2,3 더하기에서처럼 D[0]을 1로 초기화하면 중복이 발생한다.
따라서, 이 문제에서는 i가 1인경우와 그보다 작은 경우로 구분하여 초기화해야한다.

### 쉬운 계단 수

> https://www.acmicpc.net/problem/10844

인접한 자리의 차이가 1이 나는 수를 계단 수라고 한다.
$D[N][L] = 길이가 N인 계단수$로 점화식을 설정할 수 있으며 L은 마지막 수를 의미한다.

N번째 수가 L이라면 길이가 N-1인데 마지막 수가 L+1인 경우와 길이가 N-1인데 마지막 수가 L-1인 경우가 올 수 있다.
하지만 마지막 수가 0이라면 -1이 올 수 없기 때문에 이 부분을 예외처리 해줘야한다.

### 이친수

> https://www.acmicpc.net/problem/2193

0과 1로만 이루어진 수를 이진수라고 하는데, 다음 조건을 만족하면 이친수라고 한다.

1. 이친수는 0으로 시작하지 않는다.
2. 이친수에서는 1이 두 번 연속으로 나타나지 않는다. 즉, 11을 부분 문자열로 갖지 않는다.

$ D[N][L] = N자리 이친수, 마지막수 L$로 점화식을 설정할 수 있다.
$ D[N][0] = D[N-1][0] + D[N-1][1] $과 $D[N][1] = D[N-1][0]$ 두 개의 식을 생각할 수 있다.

역시 초기값을 초기화해줘야한다.
$D[1][0] = 0$, $D[1][1] =1$

1차원 배열을 이용해서 풀 수 있다.

$D[i] = i자리 이친수의 개수$로 점화식을 설정하고 0으로 끝나는 경우와 1로 끝나는 경우가 가능하다.

### 가장 긴 증가하는 부분 수열

> https://www.acmicpc.net/problem/11053

LIS (Longest Increasing Subsequence)

수열 A가 주어졌을 때, 가장 긴 증가하는 부분 수열을 구하는 문제

점화식을 고려하지 않고 DP배열을 사용하여 문제를 해결
$ D[i] = A[i]를 마지막으로 하는 가장 긴 증가하는 부분 수열의 길이 $
수열 A의 값에 따라 자기 자신만 오는 경우 1과 자기 자신 이전의 수들과 비교하여 값이 커지는 경우를 체크한다.
10, 20, 10, 30의 경우 30에서는 10, 20, 10과 전부 비교하여 해당 DP배열의 값들 중 최대값을 선택한다.
i번째 수 앞의 수를 j번째 수라고 하면 $ D[i] = max(D[j]) + 1 (j < i, A[j] < A[i])$가 된다.

각각의 수 마다 앞에있는 모든 수를 살펴봤으므로 시간복잡도는 $O(N^2)$이 된다.

문제의 조건에 따라 마지막 수가 정답이 아닐 수 있으므로 전체 DP배열중의 최대값을 구해야 할 수 있다.

### 가장 긴 증가하는 부분 수열 4

> https://www.acmicpc.net/problem/14002

가장 긴 증가하는 부분 수열 문제와 흡사하지만 수열의 수가 어떻게 이루어져있는지 구하는 문제

$V[i] = A[i]의 앞에와야 하는 수의 인덱스$배열을 추가하면 된다.
10, 20, 10, 30, 20, 50의 경우 다음과 같은 배열들을 가지게 된다.
![image-20201229101337745](C:\TIL\Algorithm\CodePlus\Foundation1\images\Dynamic Programming\image-20201229101337745.png)

수의 순서대로 출력하는 문제는 재귀를 사용하여 역추적을 진행하면된다.

### 연속합

> https://www.acmicpc.net/problem/1912

n개의 정수로 이루어진 임의의 수열에서 연속된 몇 개의 숫자를 선택해서 구할 수 있는 합 중 가장 큰 합
i번째 수가 i-1번째와 연속이거나, 연속이 아니거나의 경우가 존재
$D[i] = max(D[i-1] + A[i], A[i])$가 점화식이 된다.

시간복잡도는 모든 수 N에서 두 가지 중 하나를 선택하니까 $O(N)$이다.
다르게 생각하면, DP배열을 0번째부터 N번째까지 진행하고 끝나니까 $O(N)$이다.

### 제곱수의 합

> https://www.acmicpc.net/problem/1699

1, 2, 3 더하기 문제와 흡사하다.

주어진 자연수 N을 제곱수들의 합으로 표현할 때에 그 항의 최소개수를 구하는 문제
1, 2, 3 더하기 문제처럼 마지막에 오는 수가 중요하다. 어떤 수가 오는 지는 알 수 없으니 i로 가정한다.
마지막 수를 $i^2$일라고 가정했으니 이전의 값들은 $N-i^2$이 된다.
이를 토대로 점화식을 만들어보면 $D[N] = min(D[N-i^2]) + i^2$이 된다. 최소개수를 구하는 문제이기 때문에 min을 추가했다.
점화식에 변수가 들어가있으니 변수의 범위를 지정해본다. $1^2 \leq i^2 \leq N$이 된다.

시간복잡도는 N개의 칸을 채워야하는데 하나의 칸을 채울때는 i번 반복문을 해야되고, i는 최대 $\sqrt{N}$이므로 $O(N\sqrt{N})$이 된다.

### 합분해

> https://www.acmicpc.net/problem/2225

1, 2, 3 더하기 문제와 흡사하다.

0부터 N까지의 정수 K개를 더해서 그 합이 N이 되는 경우의 수
역시 마지막에 올 수 있는 수가 어떤 수인지 파악해본다. 0부터 N까지의 수 중 하나가 올 수 있다.
마지막에 오는 수를 L이라고 가정하면, 이전의 합은 N-L이 되며 이전의 개수는 K-1개가 된다.
이를 토대로 점화식을 만들어 보면, $D[K][N] = \sum D[K-1][N-L] \quad (0 \leq L \leq N)$이 된다. 

시간복잡도는 K개의 수를 탐색하는데 각 수는 0부터 N까지 올 수 있으므로 $O(KN^2)$이 된다.

## 연습

### 1, 2, 3 더하기 3

> https://www.acmicpc.net/problem/15988

정수 n을 1, 2, 3의 합으로 나타내는 방법의 수를 구하는 문제, 단 1,000,000,009으로 나눈 나머지를 구하는 문제

나머지를 구하는 문제는 매번 나누어주면 된다.

### RGB 거리

> https://www.acmicpc.net/problem/1149

집을 빨, 초, 파 중 하나로 칠하는데 이웃과 같은색을 칠하면 안됨.
첫 집과 마지막 집이 이웃이 아니며 각 색으로 칠하는 비용이 주어졌을 때 모든 집을 칠하는 비용의 최소값을 구하는 문제

i번째 집을 칠할 때 i-1번째 집과 다른 색으로 칠해야 한다.
1, 2, 3더하기 문제 중 i번째 수가 무엇인지 표시했던 경우와 흡사하다.
$D[i][j] = i번\ 집을\ 색\ j로\ 칠했을\ 때,\ 1~i번\ 집을\ 칠하는\ 비용의\ 최소값$이 점화식이 된다.

### 동물원

> https://www.acmicpc.net/problem/1309

가로 두칸, 세로 N칸인 동물원에서 가로, 세로로 붙어있게 배치하면 안되는 배치의 수

N번 줄에 배치하지 않는 경우 0, N번 줄의 왼쪽에만 배치하는 경우 1, N번 줄의 오른쪽에만 배치하는 경우 2로 생각한다.
0번의 위에 오게 될 수 있는 것은 0, 1, 2번
1번의 위에 오게 될 수 있는 것은 0, 2번
2번의 위에 오게 될 수 있는 것은 0, 1번이다.
이를 토대로 점화식을 생성하면 다음과 같다.
$ D[N][0] = D[N-1][0] + D[N-1][1] + D[N-1][2]$
$ D[N][1] = D[N-1][0] + D[N-1][2]$
$ D[N][2] = D[N-1][0] + D[N-1][1]$

### 오르막 수

> https://www.acmicpc.net/problem/11057

수의 자리가 오름차순을 이루는 수
인접한 수가 같아도 오름차순으로 친다.

수의 길이 N이 주어졌을 때, 오르막 수의 개수를 구하는 문제. 수는 0으로 시작할 수 있다.
예시, 1233345, 357, 8888888, 1555999

계단수 문제와 비슷하다.
계단수는 앞 수와의 차이가 1이 날 수 있지만, 오르막 수는 L 수의 앞 수가 0~L까지 올 수있다.

$D[i][j]=길이가\ i이고\ 마지막\ 수가\ j인\ 오르막\ 수의\ 개수$가 된다.
$D[1][i] = 1$이고 이를 토대로 점화식을 생성하면 $D[i][j] += D[i-1][k]\ (0 \leq k \leq j)$가 된다.

### 스티커

> https://www.acmicpc.net/problem/9465

스티커 2n개가 2 X n 모양으로 배치되어 있고, 한 장을 떼면 변을 공유하는 스티커는 사용할 수 없다.
각 스티커의 점수의 합을 최대로 만드는 문제

큰 것부터 선택하는 방법은 반례가 존재하기 때문에 정답이 아니다.

동물원과 비슷하게 0, 1, 2번 방법으로 진행한다.
$D[i][j] = 2*i에서\ 얻을\ 수\ 있는\ 최대\ 점수,\ i번\ 열에서\ 뜯는\ 스티커는\ j$로 진행한다.
j가 0이면 뜯지않고, 1이면 위쪽을, 2면 아래쪽을 뜯는 경우로 생각한다.

### 포도주 시식

> https://www.acmicpc.net/problem/2156

이친수 문제와 상당히 흡사한 문제기 때문에 넘어감

### 정수 삼각형

> https://www.acmicpc.net/problem/1932

각 칸에서 갈 수 있는 방법은 왼쪽아래 혹은 오른쪽아래가 있다.

아래로만 내려가기 때문에 DP로 풀 수 있다.

(i, j)에서 최대합이 될 경우를 생각해보면 본인에게 올 수있는 값들 중 최대값을 선택하는 경우다.
이를 토대로 점화식을 만들어보면 다음과 같다.
$D[i][j] = Max(D[i-1][j], D[i-1][j-1]) + A[i][j]$

### 가장 큰 증가하는 부분 수열

> https://www.acmicpc.net/problem/11055

LIS와 흡사하다.

수열 A가 주어졌을 때, 그 수열의 증가 부분 수열 중에서 합이 가장 큰 것을 구하는 문제

$D[i] = max(D[j] + A[i])$

### 가장 긴 감소하는 부분 수열

> https://www.acmicpc.net/problem/11722

LDS (Longest Decreasing Subsequence)

입력으로 주어진 수열 A를 뒤집어서 가장 긴 증가하는 부분 수열을 구하는 방법과
A[i]에서 시작하는 가장 긴 감소하는 부분 수열의 길이를 구하는 방법이 있다.

A[i]에서 시작하는 방법은 뒤에 있는 값들이 먼저 필요하다. 그렇기에 N번째, N-1번째 처럼 역순으로 구해야 한다.
$D[i] = max(D[j]) + 1\quad (i < j,\ A[i] > A[j])$가 점화식이 된다.

A[i]에서 끝나는 방법은 기존 LIS방법과 동일하나, 감소하기 때문에 부등호만 변경한다.
$D[i] = max(D[j]) + 1\quad (j < i,\ A[j] > A[i])$가 점화식이 된다.

### 가장 긴 바이토닉 부분 수열

> https://www.acmicpc.net/problem/11054

바이토닉이란 특정 숫자까지 증가하다가 특정 숫자 이후 줄어드는 방법이다.
LIS + LDS가 존재하는 경우다.

$D[i] = i번째에서\ 끝나는\ 증가하는\ 부분\ 수열$
$D2[i] = i번째에서\ 시작하는\ 감소하는\ 부분\ 수열$
로 두 개의 DP를 설정하고 진행한다.

### 연속합 2

> https://www.acmicpc.net/problem/13398

수열의 연속합 중 가장 큰 합을 구하는 문제.
연속합과 다르게 수를 하나 제거할 수 있다는 조건이 추가되었다. (제거하지 않아도 된다.)

연속합의 시간복잡도는 $O(N)$이다.
N개의 수가 있을 때 각각의 수를 제거하고 연속합을 구하는 방법이 있지만, 이 방법을 시도하면 $O(N)$의 시간복잡도를 N번 진행하기 때문에 $O(N^2)$의 시간복잡도를 가져서 시간초과가 발생한다.

바이토닉과 마찬가지로 두 개의 DP를 설정해본다.
$D[i] = i번째에서\ 끝나는\ 연속합$
$D2[i] = i번째에서\ 시작하는\ 연속합$
이러한 경우 K번째 수를 제거한 연속합을 구해보면 $D[K-1] + D2[K+1]$가 된다.

### 타일 채우기

> https://www.acmicpc.net/problem/2133

3 X N을 1 X 2와 2 X 1로 채우는 방법의 수
역시 마지막에 올 수 있는 경우의 수를 찾아본다.
먼저 경우의 수는 3가지이다. 각 경우의 수 모두 열의 개수가 2이다.
$D[N] = D[N-2] * 3$

하지만 경우의 수가 더 있다.
열의 길이가 4인경우와 6인경우 점점 늘어난다.
이러한 내용을 토대로 점화식을 세워보면 $D[i] = 3 \times D[i-2] + 2\times D[i-4] + 2 \times D[i-6] + \cdots$이 된다.

그림으로 그려가며 푸는 것은 적절하지 않은 방법이기에 참고용으로만 알아두면 될 것.

## 도전

### 동물원

연습문제와 동일한 문제.
더 어렵게 풀 수도 있음.

기존 동물원 문제는 왼쪽에 놓거나, 오른쪽에 놓거나, 안 놓는경우를 봤는데
여기서는 안 놓는 경우를 제외하고 진행한다.

i번째 줄에는 동물이 있어야 한다.
i번째 줄의 이전에 동물이 있는 줄은 어디일까?
i-1번째, i-2번째, ..., 2, 1번째 줄 어디든 있을 수 있다.
하지만, 동물이 붙어있을 수 없으므로 i번째에 동물이 왼쪽에 있을지 오른쪽에 있을지로 나눠서 생각해야한다.

i번째에 동물이 있으니 i-1번째에 동물이 있을 경우의 수는 D[i-1]이다.
하지만 i-2번째부터는 $2 \times D[i-2]$이다. i-1번째 줄에 동물이 놓여지지 않았을 경우에 i-2번째줄에는 왼쪽이든 오른쪽이든 놓여질 수 있기 때문이다.

이 방법을 이용하면 총 N개의 칸에 대한 정답을 구하는데, 각 칸에 대한 정답을 구할때 이전의 정답을 전부 더해줘야하므로 $O(N^2)$의 시간복잡도이다.
하지만 N이 100,000보다 작아서 시간초과가 발생할 수 있어서 S라는 새로운 배열을 이용한다.
$S[i] = D[0] + D[1] + D[2] + \cdots + D[i]$인 배열을 이용한다.
그렇게 되면 마지막 점화식은 $D[i] = D[i-1] + 2 \times S[i-2]$가 된다. 

여기서 정답은 $D[N]$이 아닌 $S[N]$에 들어있다. 
i번째 줄에 동물이 꼭 있어야 하는것인데, i번째 이후의 칸에 동물이 놓여지지 않았을 경우가 있기에
모든 경우의 수를 더한 $S[N]$이 정답이 된다.

$D[0]$도 동물을 놓지 않는 경우의 수가 있기 때문에 1이다.

### RGB 거리 2

> https://www.acmicpc.net/problem/17404

RGB거리와 동일하나, 첫집과 마지막집이 이웃이라는 조건이 추가되었다.
이웃이라는 말은 원으로 이루어져있다는 말이다.

원으로 이루어진 문제를 해결할 때는 직선으로 문제를 해결하고 원형으로 바꿔주면 된다.
1번집과 N번집의 경우의 수는 6가지이다.
1번집의 색을 고정하고 DP를 3번 수행하여 문제를 해결한다.

### 합분해

문제풀이에서 진행한 문제.

더 좋은 풀이로, $D[K][N] = D[K][N-1] + D[K-1][N]$으로 줄일 수 있다.
이럴 경우 시간복잡도가 $O(KN^2)$에서 $O(KN)$이 된다.

이외에도 2차원 DP를 1차원 DP로 변경할 수 있다.
$D2[N-2] = D2[N-3] + D2[N-2]$가 된다.
이 방법은 모든 2차원 DP에 적용되는 것은 아니고, 합분해문제에서만 가능하다.