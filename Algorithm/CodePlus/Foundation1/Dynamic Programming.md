# Dynamic Programming

## Dynamic Programming 개념

> 동적계획법
>
> 문제의 크기가 큰 문제를 작은 문제로 나눠서 푸는 알고리즘, https://en.wikipedia.org/wiki/Dynamic_programming#History

이렇게 문제의 크기를 나누는 알고리즘은 DP와 분할정복(Divide & Conquer)가 있다.
DP는 큰 문제들을 작은 문제로 나누었을 때 중복이 가능할 경우, 분할정복은 중복이 불가능할 경우이다.

DP 문제를 풀기위해서는 두 가지 속성을 만족해야 한다.
첫 번째는 Overlapping Subproblem 속성으로 겹치는 부분문제를 의미한다. 부분의 작은 문제들이 중복되면 DP로 문제를 해결한다.
두 번째는 Optimal Substructure 속성으로 최적 부분구조를 의미한다.

* **Overlapping Subproblem**
  피보나치의 수를 예시로 들어 설명한다. 피보나치의 수는 다음과 같다.
  0번째 수는 0, 1번째 수는 1로 고정되어 있고, 2번째 수부터는 이전 두 수의 합으로 이루어져 있다.
  0, 1, 1, 2, 3, 5, 8, 13, 21, ...

  $ F_{n} = F_{n-1} + F_{n-2} (n \geq 2) $

  $ F_{n} $이 여기서 큰 문제가 되고, $ F_{n-1} $과 $ F_{n-2} $가 작은 문제가 된다.
  결국 N번째 피보나치 수를 구하는 문제가 큰 문제가 되며, N-1번째와 N-2번째 피보나치 수를 구하 는 문제가 작은 문제가 된다.

  크다와 작다는 상대적이기 때문에, 이를 더 깊게 들어가면
  N-1번째 피보나치 수를 구하는 문제를 큰 문제라고 생각하면, N-2번째 피보나치수와 N-3번째 피보나치 수를 구하는 문제가 작은 문제가 된다.

  이렇게 깊게 들어가면, N번째 피보나치수와 N-1번째 피보나치 수를 구할 때 N-2번째 피보나치 수가 중복해서 들어간다는 것을 확인할 수 있다.
  이렇게 **중복되는 값이 존재할때**를 Overlapping Subproblem이라고 한다.

  **큰 문제와 작은 문제를 같은 방법으로 풀 수 있고, 문제를 작은 문제로 쪼갤 수 있다.**

* **Optimal Substructure**
  **문제의 정답을 작은 문제의 정답에서 구할 수 있다.**
  
  예를 들어, 서울에서 부산을 가는 가장 빠른 길이 대전과 대구를 순서대로 거쳐야 한다면 대전에서 부산을 가는 가장 빠른 길은 대구를 거쳐야 한다.
  만약 대전에서 부산을 가는 가장 빠른 길이 울산을 거치는 길이라면, 서울에서 부산을 가는 가장 빠른 길이 대전과 대구를 거치는 길이 아니라 대전과 울산을 거치는 길이 될 것이므로 기존의 대전과 대구를 거치는 길이라는 가정은 오류가 된다.

  이 속성을 만족한다면, 문제의 크기에 상관없이 어떤 한 문제의 정답은 일정하다.
  10번째 피보나치 수를 구할 때의 4번째 피보나치 수와 9번째 피보나치 수를 구할 때의 4번째 피보나치 수가 같다.
  결국 4번째 피보나치 수를 필요로 할 때 4번째 피보나치 수는 항상 같다.

  **DP에서 각 문제는 한 번만 풀어야 한다. 또한 같은 문제는 구할 때마다 정답이 같다.**
  그렇기에 정답을 구했으면 정답을 어딘가에 메모해 놓는다. 코드의 구현에서는 배열에 저장하는 것으로 진행할 수 있다.
  이러한 메모의 과정을 **Memoization**이라고 한다.

  이 방법을 활용하면 어떻게 개선되는지 확인한다.

  * **Memoization을 활용하지 않은 문제해결**
  
    ```c
    int fibonacci(int n) {
        if (n <= 1) {
            return n;
        } else {
            return fibonacci(n-1) + fibonacci(n-2);
        }
    }
    ```
  
    이와 같이 문제를 해결하면 해당 재귀함수가 어떻게 호출되는지 그림으로 다음과 같이 나타낼 수 있다.
    ![image-20201228104814744](C:\TIL\Algorithm\CodePlus\Foundation1\image-20201228104814744.png)
    동일한 함수가 여러번 호출되는 것을 확인할 수 있다.
  
  * **Memoization을 활용한 문제해결**

    ```c
    int memo[100];
    int fibonacci(int n) {
        if(n <= 1) {
            return n;
        } else {
            if(memo[n] > 0) {
                return memo[n];
            }
            memo[n] = fibonacci(n-1) + fibonacci(n-2);
            return memo[n];
        }
    }
    ```

    이와 같이 문제를 해결하면 해당 재귀함수가 어떻게 호출되는지 그림으로 다음과 같이 나타낼 수 있다.
    ![image-20201228105047617](C:\TIL\Algorithm\CodePlus\Foundation1\image-20201228105047617.png)
    호출되는 함수의 수가 현저히 줄어드는 것을 확인할 수 있다.
    **시간 복잡도**를 확인해보면 모든 문제를 한번씩 풀기 때문에 문제의 개수 * 문제 1개를 푸는 시간으로 계산한다.
    피보나치 수의 경우 N번째를 구하려면 총 N개의 문제를 구해야 하며
    문제 1개를 푸는 시간은 함수의 시간 복잡도와 같은 의미를 가지므로 + 하나만 있는 함수 상 O(1)이 된다.
    그러므로 총 **O(N)**이 된다.

**DP의 구현방식**에는 **Top-down(재귀)**과 **Botton-up(반복)**의 두 가지 방법이 있다.
**두 방법의 시간 차이는 알 수 없다.** 재귀에서는 스택을 활용하기 때문에 스택오버플로우가 발생할 수도 있다.
그래서 반복문을 활용하는게 더 빠르고 좋을 것 같지만, Bottom-up 방식은 정말 모든 방식을 풀기 때문에 경우에 따라 시간이 더 오래걸릴 수 있기 때문에 알 수 없다.
C++, Java의 경우 스택오버플로우가 거의 발생하지 않고, 발생할 경우는 구현을 잘못한 경우가 많기 때문에 신경쓰지 않아도 된다.

* **Bottom-up**
  문제를 크기가 작은 문제부터 차례대로 문제의 크기를 조금씩 크게 만들면서 푼다.
  **반복문**을 사용하여 해결한다.

  ```c
  int d[100];
  int fibonacci(int n) {
      d[0] = 0;
      d[1] = 1;
      for (int i=2; i<=n; i++) {
          d[i] = d[i-1] + d[i-2];
      }
      return d[n];
  }
  ```

* **Top-down**
  기존에 알아본 것 처럼 **재귀함수**를 사용한 방법

## 문제 풀이 전략

문제에서 구하려고 하는 답을 문장으로 나타내는 **점화식을 정의**하는 경우가 많다.

점화식의 정의가 문제에서 구해야 하는 값을 그대로 나타내는 경우인 문제가 존재하고,
조금 더 나아가서 **점화식의 정의를 변경**해야 하는 것을 해결한다.

## 문제 풀이

### 1로 만들기

> https://www.acmicpc.net/problem/1463

정수 X에 사용할 수 있는 연산은 다음의 세가지

1. X가 3으로 나누어 떨어지면, 3으로 나눈다.
2. X가 2로 나누어 떨어지면, 2로 나눈다.
3. 1을 뺀다

어떤 정수 N에 위와 같은 연산을 선택해서 1을 만드려고 한다. 연산을 사용하는 횟수의 최소값을 구하는 문제

3으로 나누는 것이 수를 가장 빠르게 작게 만들수 있으므로 3으로 나누는 것, 2로 나누는 것, 1을 빼는 것 순서의 우선순위로 N을 1로 만들어볼 수 있다.
하지만 이 방법에 대한 반례는 10이다. 생각한 방법대로라면 10 > 5 > 4 > 2 > 1 의 과정으로 1이 되나, 실제방법은 10 > 9 > 3 > 1이 존재한다.

이 문제에 대한 점화식을 정의한다.
$ D[N] = N을 1로 만드는 최소 연산 횟수$ 
문제의 난이도가 낮으면 문제를 작게 나눌수 있는 방법이 주어진다.
1번 연산을 사용하는 경우 N을 1로만드는 연산 횟수는 N/3을 1로 만드는 최소 연산횟수 + 1번이다.
마찬가지로 2번 연산을 사용하는 경우 N/2를 1로 만드는 최소 연산횟수 + 1번이다.

정리하면, $ D[N] = min(D[N/3], D[N/2], D[N-1]) + 1 $이 된다.

* **Top-down 방식을 활용한 풀이**

  ```c
  int go(int n) {
      if(n == 1) return 0;
      if(d[n] > 0) retrun d[n]; // Memoization
      d[n] = go(n-1) + 1; // 3번 경우
      if(n%2 == 0){ // 2번 경우
          int temp = go(n/2) + 1;
          if(d[n] > temp) d[n] = temp;
      }
      if(n%3 == 0){ // 1번 경우
          int temp = go(n/3) + 1;
          if(d[n] > temp) d[n] = temp;
      }
      return d[n];
  }
  ```

  해당 풀이과정의 시간복잡도를 살펴본다. 
  함수의 호출횟수를 의미하는 문제의 개수와 함수의 시간복잡도를 의미하는 문제 1개 푸는데 필요한 시간복잡도를 곱한다.
  문제의 개수는 N개이며, 문제 1개 푸는데 필요한 시간복잡도는 O(1)이므로 시간복잡도는 O(N)이 된다.

문제에서 선택할수 있는 연산의 순서는 N/3 > N/2 > N-1이였는데 왜 코드구현은 반대로 했는가?
최소값을 쉽게 구하기 위해서. N/3과 N/2는 각각 나누어떨어져야하는데 N-1은 그 이외의 경우에 항상 진행하기 때문에 N-1을 먼저 진행하고 이후의 과정에서 비교를 통해 최소값을 탐색한다.

* Bottom-up 방식을 활용한 풀이

  ```c
  d[1] = 0;
  for (int i=2; i<=n; i++) {
      d[i] = d[i-1] + 1;
      if(i%2 == 0 && d[i] > d[i/2] + 1) {
          d[i] = d[i/2] + 1;
      }
      if(i%3 == 0 && d[i] > d[i/3] + 1) {
          d[i] = d[i/3] + 1;
      }
  }
  ```

### 2 X n 타일링

> https://www.acmicpc.net/problem/11726

2 X n 직사각형을 1X2, 2X1 타일로 채우는 방법의 수
D[n] = 2 X n 직사각형을 채우는 방법의 수
마지막 단계를 진행하지 않았을 때 문제가 어떻게 변하는지 파악하여 문제를 해결한다.

2X1타일이 하나 오는 경우 2 X (n-1) (D[n-1])의 타일을 채우고 1번을 더하면 완성된다.
1X2타일을 사용하는 경우에는 항상 위아래로 두개가 함께 와야한다. 그러므로 2 X (n-2) (D[n-2])의 타일을 채우고 2번을 더하면 완성된다.
정리하면, $D[n] = D[n-1] + D[n-2]$가 된다. 이를 그림으로 표현하면 다음과 같다.
![image-20201228124149447](C:\TIL\Algorithm\CodePlus\Foundation1\image-20201228124149447.png)

Q. 1X2 타일을 사용하는 경우는 2개오는데 2X1 타일을 사용하는 경우는 왜 2개가 오면 안되나요?
A. 2X1 타일을 사용하는 경우는 마지막 단계 1번을 진행하지 않았을 경우에 1개만 해당되기 때문.

### 2 X n 타일링 2

> https://www.acmicpc.net/problem/11727

2 X n 직사각형을 1X2, 2X1, 2X2 타일로 채우는 방법의 수
이전문제와 동일하게 진행하며 2X2타일로 채우는 방법의 수는 1X2가 두개 들어가는 방법의 수와 동일하다.
하지만 1X2가 두개 들어가는 방법과 동일하지는 않으므로 D[n-2]를 한번 더 더해주면 된다.
결국, $ D[n] = D[n-1] + D[n-2] + D[n-2] $가 된다. 그림으로 표현하면 다음과 같다.

![image-20201228124531540](C:\TIL\Algorithm\CodePlus\Foundation1\image-20201228124531540.png)

### 1, 2, 3 더하기

> https://www.acmicpc.net/problem/9095

정수 n을 1, 2, 3의 합으로 나타내는 방법의 수를 구하는 문제

DP문제 답게 D[n]을 구하기 위해 D[n-1]을 살펴본다. 마지막 단계에는 +1, +2, +3이 올 수 있다.
n-1의 합에 1을 더하면 n이되고, n-2의 합에 2를 더하면 n이되고, n-3의 합에 3을 더하면 n이된다.
결국, $ D[n] = D[n-1] + D[n-2] + D[n-3] $이 된다.

이를 표현하기 전에, $D[0]$은 어떻게 나타내야 할지 고민해봐야한다.
+1, +2, +3 아무것도 사용하지 않고 표현할 수 있으므로 1로 나타낼수 있다.

풀이과정을 그림으로 표현해보면 다음과 같다.
![image-20201228125131703](C:\TIL\Algorithm\CodePlus\Foundation1\image-20201228125131703.png)

**지금까지 풀어본 3문제 모두 시간복잡도는 O(N)이다**.