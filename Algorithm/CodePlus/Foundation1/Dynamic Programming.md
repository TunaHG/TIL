# Dynamic Programming

## Dynamic Programming 개념

> 동적계획법
>
> 문제의 크기가 큰 문제를 작은 문제로 나눠서 푸는 알고리즘, https://en.wikipedia.org/wiki/Dynamic_programming#History

이렇게 문제의 크기를 나누는 알고리즘은 DP와 분할정복(Divide & Conquer)가 있다.
DP는 큰 문제들을 작은 문제로 나누었을 때 중복이 가능할 경우, 분할정복은 중복이 불가능할 경우이다.

DP 문제를 풀기위해서는 두 가지 속성을 만족해야 한다.
첫 번째는 Overlapping Subproblem 속성으로 겹치는 부분문제를 의미한다. 부분의 작은 문제들이 중복되면 DP로 문제를 해결한다.
두 번째는 Optimal Substructure 속성으로 최적 부분구조를 의미한다.

* **Overlapping Subproblem**
  피보나치의 수를 예시로 들어 설명한다. 피보나치의 수는 다음과 같다.
  0번째 수는 0, 1번째 수는 1로 고정되어 있고, 2번째 수부터는 이전 두 수의 합으로 이루어져 있다.
  0, 1, 1, 2, 3, 5, 8, 13, 21, ...

  $ F_{n} = F_{n-1} + F_{n-2} (n \geq 2) $

  $ F_{n} $이 여기서 큰 문제가 되고, $ F_{n-1} $과 $ F_{n-2} $가 작은 문제가 된다.
  결국 N번째 피보나치 수를 구하는 문제가 큰 문제가 되며, N-1번째와 N-2번째 피보나치 수를 구하 는 문제가 작은 문제가 된다.

  크다와 작다는 상대적이기 때문에, 이를 더 깊게 들어가면
  N-1번째 피보나치 수를 구하는 문제를 큰 문제라고 생각하면, N-2번째 피보나치수와 N-3번째 피보나치 수를 구하는 문제가 작은 문제가 된다.

  이렇게 깊게 들어가면, N번째 피보나치수와 N-1번째 피보나치 수를 구할 때 N-2번째 피보나치 수가 중복해서 들어간다는 것을 확인할 수 있다.
  이렇게 **중복되는 값이 존재할때**를 Overlapping Subproblem이라고 한다.

  **큰 문제와 작은 문제를 같은 방법으로 풀 수 있고, 문제를 작은 문제로 쪼갤 수 있다.**

* **Optimal Substructure**
  **문제의 정답을 작은 문제의 정답에서 구할 수 있다.**
  
  예를 들어, 서울에서 부산을 가는 가장 빠른 길이 대전과 대구를 순서대로 거쳐야 한다면 대전에서 부산을 가는 가장 빠른 길은 대구를 거쳐야 한다.
  만약 대전에서 부산을 가는 가장 빠른 길이 울산을 거치는 길이라면, 서울에서 부산을 가는 가장 빠른 길이 대전과 대구를 거치는 길이 아니라 대전과 울산을 거치는 길이 될 것이므로 기존의 대전과 대구를 거치는 길이라는 가정은 오류가 된다.

  이 속성을 만족한다면, 문제의 크기에 상관없이 어떤 한 문제의 정답은 일정하다.
  10번째 피보나치 수를 구할 때의 4번째 피보나치 수와 9번째 피보나치 수를 구할 때의 4번째 피보나치 수가 같다.
  결국 4번째 피보나치 수를 필요로 할 때 4번째 피보나치 수는 항상 같다.

  **DP에서 각 문제는 한 번만 풀어야 한다. 또한 같은 문제는 구할 때마다 정답이 같다.**
  그렇기에 정답을 구했으면 정답을 어딘가에 메모해 놓는다. 코드의 구현에서는 배열에 저장하는 것으로 진행할 수 있다.
  이러한 메모의 과정을 **Memoization**이라고 한다.

  이 방법을 활용하면 어떻게 개선되는지 확인한다.

  * **Memoization을 활용하지 않은 문제해결**
  
    ```c
    int fibonacci(int n) {
        if (n <= 1) {
            return n;
        } else {
            return fibonacci(n-1) + fibonacci(n-2);
        }
    }
    ```
  
    이와 같이 문제를 해결하면 해당 재귀함수가 어떻게 호출되는지 그림으로 다음과 같이 나타낼 수 있다.
    ![image-20201228104814744](C:\TIL\Algorithm\CodePlus\Foundation1\images\image-20201228104814744.png)
    동일한 함수가 여러번 호출되는 것을 확인할 수 있다.
  
  * **Memoization을 활용한 문제해결**

    ```c
    int memo[100];
    int fibonacci(int n) {
        if(n <= 1) {
            return n;
        } else {
            if(memo[n] > 0) {
                return memo[n];
            }
            memo[n] = fibonacci(n-1) + fibonacci(n-2);
            return memo[n];
        }
    }
    ```

    이와 같이 문제를 해결하면 해당 재귀함수가 어떻게 호출되는지 그림으로 다음과 같이 나타낼 수 있다.
    ![image-20201228105047617](C:\TIL\Algorithm\CodePlus\Foundation1\images\image-20201228105047617.png)
    호출되는 함수의 수가 현저히 줄어드는 것을 확인할 수 있다.
    **시간 복잡도**를 확인해보면 모든 문제를 한번씩 풀기 때문에 문제의 개수 * 문제 1개를 푸는 시간으로 계산한다.
    피보나치 수의 경우 N번째를 구하려면 총 N개의 문제를 구해야 하며
    문제 1개를 푸는 시간은 함수의 시간 복잡도와 같은 의미를 가지므로 + 하나만 있는 함수 상 O(1)이 된다.
    그러므로 총 **O(N)**이 된다.

**DP의 구현방식**에는 **Top-down(재귀)**과 **Botton-up(반복)**의 두 가지 방법이 있다.
**두 방법의 시간 차이는 알 수 없다.** 재귀에서는 스택을 활용하기 때문에 스택오버플로우가 발생할 수도 있다.
그래서 반복문을 활용하는게 더 빠르고 좋을 것 같지만, Bottom-up 방식은 정말 모든 방식을 풀기 때문에 경우에 따라 시간이 더 오래걸릴 수 있기 때문에 알 수 없다.
C++, Java의 경우 스택오버플로우가 거의 발생하지 않고, 발생할 경우는 구현을 잘못한 경우가 많기 때문에 신경쓰지 않아도 된다.

* **Bottom-up**
  문제를 크기가 작은 문제부터 차례대로 문제의 크기를 조금씩 크게 만들면서 푼다.
  **반복문**을 사용하여 해결한다.

  ```c
  int d[100];
  int fibonacci(int n) {
      d[0] = 0;
      d[1] = 1;
      for (int i=2; i<=n; i++) {
          d[i] = d[i-1] + d[i-2];
      }
      return d[n];
  }
  ```

* **Top-down**
  기존에 알아본 것 처럼 **재귀함수**를 사용한 방법

## 문제 풀이 전략

문제에서 구하려고 하는 답을 문장으로 나타내는 **점화식을 정의**하는 경우가 많다.

점화식의 정의가 문제에서 구해야 하는 값을 그대로 나타내는 경우인 문제가 존재하고,
조금 더 나아가서 **점화식의 정의를 변경**해야 하는 것을 해결한다.

## 문제 풀이

### 1로 만들기

> https://www.acmicpc.net/problem/1463

정수 X에 사용할 수 있는 연산은 다음의 세가지

1. X가 3으로 나누어 떨어지면, 3으로 나눈다.
2. X가 2로 나누어 떨어지면, 2로 나눈다.
3. 1을 뺀다

어떤 정수 N에 위와 같은 연산을 선택해서 1을 만드려고 한다. 연산을 사용하는 횟수의 최소값을 구하는 문제

3으로 나누는 것이 수를 가장 빠르게 작게 만들수 있으므로 3으로 나누는 것, 2로 나누는 것, 1을 빼는 것 순서의 우선순위로 N을 1로 만들어볼 수 있다.
하지만 이 방법에 대한 반례는 10이다. 생각한 방법대로라면 10 > 5 > 4 > 2 > 1 의 과정으로 1이 되나, 실제방법은 10 > 9 > 3 > 1이 존재한다.

이 문제에 대한 점화식을 정의한다.
$ D[N] = N을 1로 만드는 최소 연산 횟수$ 
문제의 난이도가 낮으면 문제를 작게 나눌수 있는 방법이 주어진다.
1번 연산을 사용하는 경우 N을 1로만드는 연산 횟수는 N/3을 1로 만드는 최소 연산횟수 + 1번이다.
마찬가지로 2번 연산을 사용하는 경우 N/2를 1로 만드는 최소 연산횟수 + 1번이다.

정리하면, $ D[N] = min(D[N/3], D[N/2], D[N-1]) + 1 $이 된다.

* **Top-down 방식을 활용한 풀이**

  ```c
  int go(int n) {
      if(n == 1) return 0;
      if(d[n] > 0) retrun d[n]; // Memoization
      d[n] = go(n-1) + 1; // 3번 경우
      if(n%2 == 0){ // 2번 경우
          int temp = go(n/2) + 1;
          if(d[n] > temp) d[n] = temp;
      }
      if(n%3 == 0){ // 1번 경우
          int temp = go(n/3) + 1;
          if(d[n] > temp) d[n] = temp;
      }
      return d[n];
  }
  ```

  해당 풀이과정의 시간복잡도를 살펴본다. 
  함수의 호출횟수를 의미하는 문제의 개수와 함수의 시간복잡도를 의미하는 문제 1개 푸는데 필요한 시간복잡도를 곱한다.
  문제의 개수는 N개이며, 문제 1개 푸는데 필요한 시간복잡도는 O(1)이므로 시간복잡도는 O(N)이 된다.

문제에서 선택할수 있는 연산의 순서는 N/3 > N/2 > N-1이였는데 왜 코드구현은 반대로 했는가?
최소값을 쉽게 구하기 위해서. N/3과 N/2는 각각 나누어떨어져야하는데 N-1은 그 이외의 경우에 항상 진행하기 때문에 N-1을 먼저 진행하고 이후의 과정에서 비교를 통해 최소값을 탐색한다.

* Bottom-up 방식을 활용한 풀이

  ```c
  d[1] = 0;
  for (int i=2; i<=n; i++) {
      d[i] = d[i-1] + 1;
      if(i%2 == 0 && d[i] > d[i/2] + 1) {
          d[i] = d[i/2] + 1;
      }
      if(i%3 == 0 && d[i] > d[i/3] + 1) {
          d[i] = d[i/3] + 1;
      }
  }
  ```

### 2 X n 타일링

> https://www.acmicpc.net/problem/11726

2 X n 직사각형을 1X2, 2X1 타일로 채우는 방법의 수
D[n] = 2 X n 직사각형을 채우는 방법의 수
마지막 단계를 진행하지 않았을 때 문제가 어떻게 변하는지 파악하여 문제를 해결한다.

2X1타일이 하나 오는 경우 2 X (n-1) (D[n-1])의 타일을 채우고 1번을 더하면 완성된다.
1X2타일을 사용하는 경우에는 항상 위아래로 두개가 함께 와야한다. 그러므로 2 X (n-2) (D[n-2])의 타일을 채우고 2번을 더하면 완성된다.
정리하면, $D[n] = D[n-1] + D[n-2]$가 된다. 이를 그림으로 표현하면 다음과 같다.
![image-20201228124149447](C:\TIL\Algorithm\CodePlus\Foundation1\images\image-20201228124149447.png)

Q. 1X2 타일을 사용하는 경우는 2개오는데 2X1 타일을 사용하는 경우는 왜 2개가 오면 안되나요?
A. 2X1 타일을 사용하는 경우는 마지막 단계 1번을 진행하지 않았을 경우에 1개만 해당되기 때문.

### 2 X n 타일링 2

> https://www.acmicpc.net/problem/11727

2 X n 직사각형을 1X2, 2X1, 2X2 타일로 채우는 방법의 수
이전문제와 동일하게 진행하며 2X2타일로 채우는 방법의 수는 1X2가 두개 들어가는 방법의 수와 동일하다.
하지만 1X2가 두개 들어가는 방법과 동일하지는 않으므로 D[n-2]를 한번 더 더해주면 된다.
결국, $ D[n] = D[n-1] + D[n-2] + D[n-2] $가 된다. 그림으로 표현하면 다음과 같다.

![image-20201228124531540](C:\TIL\Algorithm\CodePlus\Foundation1\images\image-20201228124531540.png)

### 1, 2, 3 더하기

> https://www.acmicpc.net/problem/9095

정수 n을 1, 2, 3의 합으로 나타내는 방법의 수를 구하는 문제

DP문제 답게 D[n]을 구하기 위해 D[n-1]을 살펴본다. 마지막 단계에는 +1, +2, +3이 올 수 있다.
n-1의 합에 1을 더하면 n이되고, n-2의 합에 2를 더하면 n이되고, n-3의 합에 3을 더하면 n이된다.
결국, $ D[n] = D[n-1] + D[n-2] + D[n-3] $이 된다.

이를 표현하기 전에, $D[0]$은 어떻게 나타내야 할지 고민해봐야한다.
+1, +2, +3 아무것도 사용하지 않고 표현할 수 있으므로 1로 나타낼수 있다.

풀이과정을 그림으로 표현해보면 다음과 같다.
![image-20201228125131703](C:\TIL\Algorithm\CodePlus\Foundation1\images\image-20201228125131703.png)

**지금까지 풀어본 3문제 모두 시간복잡도는 O(N)이며, 점화식을 정의하면 문제가 해결되는 경우이다.**

### 카드 구매하기

> https://www.acmicpc.net/problem/11052

N개의 카드를 구매하는데 카드팩은 총 N가지 종류가 있다.
i번째 카드팩은 i개의 카드를 담고 있고, 가격은 P[i]원이다.
카드 N개를 구매하는 비용의 최대값을 구하는 문제

마지막 카드팩에 카드가 몇개가 들었을지 생각해보면 개수를 알 수 없다.
보통 알고리즘에서는 알 수 없다면 생각을 잘못한것이지만 DP에서는 알 수 없다가 나와도 괜찮다. 모든 경우의 수를 다 해보면 되기 때문이다.
마지막 카드팩에 i개의 카드가 들어있었다면 그 전까지 구매한 카드팩에는 N-i개의 카드가 들어있었을 것이다.
이를 기반으로 점화식을 만들어본다.

$ D[N] = max(P[i] + D[N - i]) $가 되며 i의 범위는 1부터 N까지가 된다.
점화식만으로 시간복잡도를 계산해 볼 수 있다. N개 X O(N)이므로 O(N제곱)이다.

### 카드 구매하기 2

> https://www.acmicpc.net/problem/16194

카드 구매하기 1과 흡사하지만 최대값이 아닌 최소값을 구하는 문제다.
max만 min으로 변경하면 될 것 같지만 그렇지 않다.

DP 배열에 항상 0이 들어가나, 카드를 구매하는 비용은 0보다 크기 때문에 min의 결과는 항상 0이다.
그래서 배열의 초기값을 잘 설정해야 한다.

첫번째 방법은 1000 * 10000으로 초기화하는 방법이다.
문제에 주어진 조건으로 카드의 개수는 1000보다 작고 카드팩의 가격은 10000보다 작기때문에 최대값으로 초기화하는 방법이다.

두번째 방법은 -1로 초기화하는 방법이다.
-1로 전부 초기화한 이후 -1이라면 아직 정답을 구하지 않았다는 의미이다.

경우의 수를 구할때는 0이라는 경우의 수가 존재할 수 있기 때문에 최대값이 아닌 -1로 초기화하는 것을 추천한다.

### 1, 2, 3 더하기 5

> https://www.acmicpc.net/problem/15990

위의 문제에서 같은 수를 두 번 인상 연속해서 사용하면 안된다는 조건이 추가된 문제이다.

연속과 같은 경우에는 두개를 묶어주면 된다.
두 번 이상 연속하면 안된다는 경우에는 

$D[i][j]$를 활용하여 i를 1, 2, 3의 합으로 나타내는 방법의수, j를 마지막에 사용한 수로 생각한다.
$D[i][1] = D[i-1][2] + D[i-1][3]$과 같은 방식을 활용한다.

1,2,3 더하기에서처럼 D[0]을 1로 초기화하면 중복이 발생한다.
따라서, 이 문제에서는 i가 1인경우와 그보다 작은 경우로 구분하여 초기화해야한다.

### 쉬운 계단 수

> https://www.acmicpc.net/problem/10844

인접한 자리의 차이가 1이 나는 수를 계단 수라고 한다.
$D[N][L] = 길이가 N인 계단수$로 점화식을 설정할 수 있으며 L은 마지막 수를 의미한다.

N번째 수가 L이라면 길이가 N-1인데 마지막 수가 L+1인 경우와 길이가 N-1인데 마지막 수가 L-1인 경우가 올 수 있다.
하지만 마지막 수가 0이라면 -1이 올 수 없기 때문에 이 부분을 예외처리 해줘야한다.

### 이친수

> https://www.acmicpc.net/problem/2193

0과 1로만 이루어진 수를 이진수라고 하는데, 다음 조건을 만족하면 이친수라고 한다.

1. 이친수는 0으로 시작하지 않는다.
2. 이친수에서는 1이 두 번 연속으로 나타나지 않는다. 즉, 11을 부분 문자열로 갖지 않는다.

$ D[N][L] = N자리 이친수, 마지막수 L$로 점화식을 설정할 수 있다.
$ D[N][0] = D[N-1][0] + D[N-1][1] $과 $D[N][1] = D[N-1][0]$ 두 개의 식을 생각할 수 있다.

역시 초기값을 초기화해줘야한다.
$D[1][0] = 0$, $D[1][1] =1$

1차원 배열을 이용해서 풀 수 있다.

$D[i] = i자리 이친수의 개수$로 점화식을 설정하고 0으로 끝나는 경우와 1로 끝나는 경우가 가능하다.