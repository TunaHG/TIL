# Java

## OOP

객체지향 프로그래밍 (Object Oriented Programming)
인간 중심적 프로그래밍, 현실 세계를 코드로 옮겨와 프로그래밍하는 것.
현실 세계의 사물들을 객체라고 보고 그 객체로부터 개발하고자 하는 애플리케이션에 필요한 특징들을 뽑아와 프로그래밍하는 것. 이를 추상화라 한다.

* 장점
  이미 작성한 코드에 대한 재사용성이 높다.
  자주 사용되는 로직을 라이브러리로 만들어두면 계속해서 사용할 수 있으며 그 신뢰성 또한 확보할 수 있다.
  또한 라이브러리를 각종 예외상황에 맞게 잘 만들어두면 개발자가 사소한 실수를 하더라도 그 에러를 컴파일 단계에서 잡아낼 수 있어 버그 발생이 줄어든다.
  또한 내부적으로 어떻게 동작하는지 몰라도 라이브러리가 제공하는 기능들을 사용할 수 있기에 생산성이 높아진다.
  객체 단위로 코드가 나뉘어져 작성되기 때문에 디버깅이 쉽고 유지보수에 용이하다.
  데이터 모델링시 객체와 매핑하는 것이 수월하기 때문에 요구사항을 보다 명확하게 파악하여 프로그래밍할 수 있다.
* 단점
  객체 간의 정보 교환이 모두 메시지 교환을 통해 일어나므로 실행 시스템에 많은 Overhead가 발생한다. (하드웨어의 발전으로 많은 부분 보완되었다.)
  객체가 상태를 가질 수 있다. 변수가 존재하고 이 변수를 통해 객체가 예측할 수 없는 상태를 가지게 되어 애플리케이션 내부에서 버그를 발생시킨다.

### 객체지향적 설계원칙

1. 단일 책임 원칙, SRP(Single Responsibility Principle)
   클래스는 단 하나의 책임을 가져야 하며 클래스를 변경하는 이유는 단 하나의 이유여야 한다.
2. 개방-폐쇄 원칙, OCP(Open-Closed Principle)
   확장에는 열려있어야 하고 변경에는 닫혀있어야 한다.
   확장에 대해 열려있다는 것은 요구 사항이 변경될 때 새로운 동작을 추가해 모듈을 확장할 수 있다는 의미다.
   변경에 대해 닫혀있다는 것은 모듈의 소스 코드나 바이너리 코드를 수정하지 않아도 모듈의 기능을 확장하거나 변경할 수 있다는 의미다.
   추상화를 통한 원칙, 고정되기는 해도 제한되지는 않은 가능한 동작의 묶음을 표현하는 추상화가 가능하다. 이런 모듈은 고정된 추상화에 의존하기 때문에 수정에 대해 닫혀 있을 수 있고 반대로 추상화의 새 파생 클래스를 만드는 것을 통해 확장도 가능하다.
3. 리스코프 치환 원칙, LSP(Liskov Substitution Principle)
   상위 타입의 객체를 하위 타입의 객체로 치환해도 상위 타입을 사용하는 프로그램은 정상적으로 동작해야 한다.
4. 인터페이스 분리 원칙, ISP(Interface Segregation Principle)
   인터페이스는 그 인터페이스를 사용하는 클라이언트를 기준으로 분리해야 한다.
5. 의존 역전 원칙, DIP(Dependency Inversion Principle)
   고수준 모듈은 저수준 모듈의 구현에 의존해서는 안된다.

