# Process VS Thread

* Process와 Thread의 차이는 무엇인가?
  * Process는 컴퓨터에서 연속적으로 실행되고 있는 컴퓨터 프로그램으로 운영체제로부터 시스템 자원을 할당받는 작업의 단위이다. Thread는 프로세스 내에서 실행되는 여러 흐름의 단위로 프로세스가 할당받은 자원을 이용하는 실행의 단위이다.
  * 프로세스는 실행될 때 운영체제로부터 프로세서, 필요한 주소 공간, 메모리 등 자원을 각각의 독립된 메모리 영역에 할당받습니다. 스레드란 한 프로세스 내에서 동작되는 여러 실행의 흐름으로 프로세스 내에서 Stack을 제외한 메모리 영역을 같은 프로세스 내에 스레드끼리 공유하고 Stack을 따로 할당받아 실행된다.

## Process

> 컴퓨터에서 연속적으로 실행되고 있는 컴퓨터 프로그램

* 종종 스케줄링의 대상이 되는 작업(Task)라는 용어와 거의 같은 의미로 사용한다.
* 여러 개의 프로세서를 사용하는 것을 멀티 프로세싱
* 여러 개의 프로그램을 띄우는 시분할 방식을 멀티 태스킹

### 프로세스 구성

> 프로세스에 대한 정보는 프로세스 제어블록(PCB : Process Control Block) 또는 프로세스 기술자(Process Discriptor)라고 부르는 자료구조에 저장된다.
>
> PCB 자료구조는 다음과 같은 정보를 가지고 있다.

* PID
  * 운영체제가 각 프로세스를 식별하기 위해 부여된 프로세스 식별번호(PID : Process IDentification)
* 프로세스 상태
  * CPU는 프로세스를 빠르게 교체하면서 실행하기 때문에 실행중인 프로세스도 있고 대기 중인 프로세스도 있다. 그런 프로세스의 상태를 저장한다.
* 프로그램 카운터
  * CPU가 다음으로 실행할 명령어를 가리키는 값
  * CPU는 기계어로 한 단위씩 읽어서 처리하는데,
    프로세스를 실행하기 위해 다음으로 실행할 기계어가 저장된 메모리주소를 가리키는 값
* 스케줄링 우선순위
  * 운영체제는 여러 개의 프로세스를 동시에 실행하는 환상을 제공한다.
  * 여러 개의 프로세스가 CPU에서 실행되는 순서를 운영체제가 결정하는 것을 스케줄링이라고 한다.
  * 스케줄링에서 우선순위가 높으면 먼저 실행될 수 있는데 이를 스케줄링 우선순위라고 한다.
* 권한
  * 프로세스가 접근할 수 있는 자원을 결정하는 정보
* 프로세스의 부모와 자식 프로세스
  * 최초로 생성되는 init 프로세스를 제외하고 모든 프로세스는 부모 프로세스를 복제해서 생성되고 이 계층관계는 트리를 형성한다.
  * 각 프로세스는 자식 프로세스와 부모 프로세스에 대한 정보를 가지고 있다.
* 프로세스의 데이터와 명령어가 있는 메모리 위치를 가리키는 포인터
  * 프로세스는 실행중인 프로그램이므로 프로그램에 대한 정보를 가지고 있어야 한다.
  * 프로그램에 대한 정보는 프로세스가 가지는 자신만의 주소 공간에 저장한다.
  * 이 공간에 대한 포인터 값을 가진다.
* 프로세스에 할당된 자원들을 가리키는 포인터
* 실행문맥
  * 프로세스가 실행상태에서 마지막으로 실행한 프로세서의 레지스터 내용을 담고있다.
  * CPU에 실행되는 프로세스는 운영체제에 의해 계속 교체되는데, 교체되었다가 다시 자신의 차례가 되어서 실행될 때 중단된 적 없고 마치 연속적으로 실행된 것처럼 하기 위해 이 레지스터 정보를 가지고 있다.

### 프로세스 상태 전이

> 프로세스가 시스템 내에 존재하는 동안 프로세스의 상태가 변하는 것을 의미

![프로세스과정](image/99B907505C590D3905.png)

* 프로세스 상태
  * **제출** : 작업을 처리하기 위해 사용자가 작업을 시스템에 제출한 상태
  * **접수 :** 제출된 작업이 스풀 공간인 디스크의 할당 위치에 저장된 상태
  * **준비 :** 프로세스가 프로세서를 할당받기 위해 기다리고 있는 상태
    * 프로세스는 준비상태 큐(스케줄링 큐)에서 실행을 준비하고 있으며 
      접수상태에서 준비 상태로의 전이는 Job 스케줄러에 의해 수행
  * **실행 :** 준비상태 큐에 있는 프로세스가 프로세서를 할당받아 실행되는 상태
    * 프로세스 수행이 완료되기 전에 프로세스에게 주어진 프로세서 할당 시간이 종료 되면 프로세스는 준비상태로 전환
    * 실행중인 프로세스에 입출력 처리가 필요하면 실행중인 프로세스는 대기상태로 전이되며, 실행상태로의 전이는 CPU 스케줄러에 의해 수행
  * **대기 :** 프로세스에 입출력 처리가 필요하면 현재 실행중인 프로세스가 중단되고, 입출력 처리가 완료될떄까지 대기하고 있는상태
  * **종료 :** 프로세스의 실행이 끝나고 프로세스 할당이 해제된 상태
* 프로세스 상태 전이 용어
  * **Dispatch :** 준비 상태에서 대기하고 있는 프로세스 중 하나가 프로세서를 할당받아 실행 상태로 전이되는 과정
  * **Wake Up :** 입 출력 작업이 완료되어 프로세스가 대기 상태에서 준비 상태로 전이되는 과정
  * **Spooling :** 입 출력 장치의 공유 및 상대적으로 느린 입출력 장치의 처리속도를 보완하고 다중 프로그래밍 시스템의 성능을 향상시키기 위해 입 출력할 데이터를 직접 입출력장치에 보내지 않고 나중에 한꺼번에 입출력하기 위해 디스크에 저장하는 과정
  * **교통량 제어기 :** 프로세스의 상태에 대한 조사와 통보 담당

### Program VS Process

* Program
  * 일반적으로 하드디스크 등에 저장되어 있는 실행코드
  * 실행되기를 기다리는 명령어(코드)와 정적인 데이터의 묶음
* Process
  * Program을 구동하여 Program 자체와 Program의 상태가 메모리 상에서 실행되는 작업 단위를 지칭
  * 프로그램의 명령어와 정적 데이터가 메모리에 적재되면 생명이 있는 프로세스가 됨
* 하나의 Program을 여러 번 구동하면 여러 개의 Process가 메모리 상에서 실행된다.
* 즉, 프로세스란 실행 중인 프로그램

### Context Switching

* 인터럽트나 시스템 호출 등으로 실행 중인 프로세스의 제어를 다른 프로세스에 넘겨 실행 상태가 되도록 하는 것을 의미한다.
* 프로세스 문맥 교환이 일어나면 프로세서의 레지스터에 있던 내용을 나중에 사용할 수 있도록 저장한다.
* 구체적으로, 동작 중인 프로세스가 대기를 하면서 해당 프로세스의 상태(Context)를 보관하고, 대기하고 있던 다음 순서의 프로세스가 동작하면서 이전에 보관했던 프로세스의 상태를 복구하는 작업을 말한다.

### Multi Processing

* 하나의 응용프로그램을 여러 개의 프로세스로 구성하여 각 프로세스가 하나의 작업을 처리하도록 하는 것
* 하나의 CPU, 즉 **프로세서는 한순간에 하나의 프로세스만 실행**할 수 있다.
* 장점
  * 여러 개의 자식 프로세스 중 하나에 문제가 발생하면 그 자식 프로세스만 죽는 것 이상으로 다른 영향이 확산되지 않는다.
* 단점
  * Context Switching에서의 오버헤드
    * Context Switching 과정에서 캐쉬 메모리 초기화 등 무거운 작업이 진행되고 많은 시간이 소모되는 등의 오버헤드가 발생한다.
    * 프로세스는 각각의 독립된 메모리 영역을 할당받았기 때문에 프로세스 사이에서 공유하는 메모리가 없다. 그래서 Context Switching이 발생하면 캐쉬에 있는 모든 데이터를 모두 리셋하고 다시 캐쉬정보를 불러와야 한다.
  * 프로세스 사이의 어렵고 복잡한 통신 기법(IPC)
    * 프로세스는 각각의 독립된 메모리 영역을 할당받았기 때문에 하나의 프로그램에 속하는 프로세스들 사이의 변수를 공유할 수 없다.
* 컴퓨터 한 대에서 멀티프로세스를 몇 개나 돌릴 수 있는가?
  * CPU에 달려있는 Core수로 결정
    * 요즘은 4 Core가 많고, 1 Core당 vCores(Virtual Cores) 2개를 할당
  * 오래 돌리는 작업을 4Core 컴퓨터에서 돌리면 5 ~ 7개의 프로세스를 돌리는게 적합
    * 컴퓨터엔 해당 작업만 존재하는 것이 아니기때문에 항상 1개 이상의 여분을 남겨야함

## Thread

> 프로세스 내에서 실행되는 여러 흐름의 단위

* 프로세스의 특정한 수행 경로
* 프로세스가 할당받는 자원을 이용하는 실행의 단위

### 스레드 특징

* 프로세스 내에서 각각 Stack만 따로 할당받고 Code, Data, Heap 영역은 공유한다.
  * Stack은 함수 호출 시 전달되는 인자, 되돌아갈 주소값 및 함수 내에서 선언하는 변수 등을 저장하기 위해 사용되는 메모리 공간이다.
  * Stack 메모리 공간이 독립적이라는 것은 독립적인 함수 호출이 가능하다는 것이고, 이는 독립적인 실행 흐름이 추가되는 것이다.
* 한 프로세스 내에서 동작되는 여러 실행의 흐름으로, 프로세스 내의 주소 공간이나 자원들(힙 공간 등)을 같은 프로세스 내에 스레드끼리 공유하면서 실행된다.
* 같은 프로세스 안에 있는 여러 스레드들은 같은 힙 공간을 공유한다. 반면에 프로세스는 다른 프로세스의 메모리에 직접 접근할 수 없다.
* 각각의 스레드는 별도의 레지스터와 스택을 갖고 있지만, 힙 메모리는 서로 읽고 쓸 수 있다.
  * PC 레지스터는 스레드가 명령어의 어디까지 수행하였는지를 나타낸다.
  * 스레드는 CPU를 할당받았다가 스케줄러에 의해 다시 선점당하는데 그렇기에 명령어가 연속적으로 수행되지 못하고 어느 부분까지 수행했는지 기억할 필요가 있다.
* 한 스레드가 프로세스 자원을 변경하면, 다른 이웃 스레드도 그 변경 결과를 즉시 볼 수 있다.

### Java Thread

* 일반 스레드와 거의 차이가 없으며 JVM이 운영체제 역할을 한다.
* Java에는 프로세스가 존재하지 않고 스레드만 존재하며, Java Thread는 JVM에 의해 스케줄되는 실행 단위 코드 블록이다.
* Java에서 스레드 스케줄링은 전적으로 JVM에 의해서 이루어진다.
* 스레드와 관련된 정보들도 JVM이 관리한다.
  * 스레드가 몇 개 존재하는지
  * 스레드로 실행되는 프로그램 코드의 메모리 위치는 어디인지
  * 스레드의 상태는 무엇인지
  * 스레드 우선순위는 얼마인지
* 즉, 개발자는 Java Thread로 작동할 스레드 코드를 작성하고, 스레드 코드가 생명을 가지고 실행을 하도록 JVM에 요청하는 일만 한다.

### Multi thread

* 하나의 응용프로그램을 여러 개의 스레드로 구성하고 각 스레드로 하여금 하나의 작업을 처리하도록 하는 것
* 윈도우, 리눅스 등의 많은 운영체제들이 멀티 프로세싱을 지원하고 있지만 멀티 스레딩을 기본으로 하고 있다.
* 웹 서버는 대표적인 멀티 스레드 응용 프로그램이다.
* 장점
  * 시스템 자원 소모 감소 (자원의 효율성 증대)
    * 프로세스를 생성하여 자원을 할당하는 시스템 콜이 줄어들어 자원을 효율적으로 관리할 수 있다.
  * 시스템 처리량 증가 (처리 비용 감소)
    * 스레드 간 데이터를 주고 받는 것이 간단해지고 시스템 자원 소모가 줄어들게 된다.
    * 스레드 사이의 작업량이 작아 Context Switching이 빠르다.
  * 간단한 통신 방법으로 인한 프로그램 응답시간 단축
    * 스레드는 프로세스 내의 Stack영역을 제외한 모든 메모리를 공유하기 때문에 통신의 부담이 적다.
* 단점
  * 주의 깊은 설계가 필요하다.
  * 디버깅이 까다롭다
  * 단일 프로세스 시스템의 경우 효과를 기대하기 어렵다.
  * 다른 프로세스에서 스레드를 제어할 수 없다.
    * 즉, 프로세스 밖에서 스레드 각각을 제어할 수 없다.
  * 멀티 스레드의 경우 자원 공유의 문제가 발생한다. (동기화 문제)
  * 하나의 스레드에 문제가 발생하면 전체 프로세스가 영향을 받는다.

## Mutli Process 대신 Multi Thread를 사용하는 이유

* 멀티 프로세스 대신 멀티 스레드를 사용하는 것은?
  * 간단히, 프로그램을 여러 개 키는 것보다 하나의 프로그램 안에서 여러 작업을 해결하는 것
* 여러 프로세스(멀티 프로세스)로 할 수 있는 작업들을 하나의 프로세스에서 여러 스레드로 나눠서 하는 이유?
  * 자원의 효율성 증대
    * 멀티프로세스로 실행되는 작업을 멀티 스레드로 실행할 경우,
      프로세스를 생성하여 자원을 할당하는 시스템 콜이 줄어들어 자원을 효율적으로 관리할 수 있다.
      * 프로세스간의 Context Switching시 단순히 CPU 레지스터 교체 뿐만 아니라 RAM과 CPU사이의 캐쉬메모리에 대한 데이터까지 초기화되므로 오버헤드가 크기때문이다.
    * 스레드는 프로세스 내의 메모리를 공유하기 때문에 독립적인 프로세스와 달리 스레드 간 데이터를 주고 받는 것이 간단해지고 시스템 자원 소모가 줄어들게 된다.
  * 처리 비용 감소 및 응답 시간 단축
    * 프로세스 간의 통신(IPC)보다 스레드 간의 통신의 비용이 적으므로 작업들 간의 통신의 부담이 줄어든다.
      * 스레드는 Stack 영역을 제외한 모든 메모리를 공유하기 때문
    * 프로세스 간의 전환 속도보다 스레드 간의 전환 속도가 빠르다.
      * Context Switching시 스레드는 Stack 영역만 처리하기 때문
* 주의
  * **동기화 문제**
  * 스레드 간의 자원 공유는 전역 변수(데이터 세그먼트)를 이용하므로 함께 상용할 때 충돌이 발생할 수 있다.

## 참고자료

* [프로세스란 무엇인가?](https://coding-factory.tistory.com/307)
* [프로세스가 뭐지?](https://bowbowbow.tistory.com/16)
* [프로세스란?](https://coding-start.tistory.com/198)
* [프로세스와 스레드의 차이](https://brunch.co.kr/@kd4/3)
* [[OS]프로세스와 스레드의 차이](https://gmlwjd9405.github.io/2018/09/14/process-vs-thread.html)
  * 가장 많이 참고하고 보기 좋게 되어있던 사이트
* [Thread에서 Stack과 PC Register를 독립적으로 할당하는 이유](https://k39335.tistory.com/30)

